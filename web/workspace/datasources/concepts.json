{
  "datasource": {
    "key": "concepts",
    "name": "Detailed explination of the concepts behind the DADI platform",
    "requestParams": [
      {
        "param": "concept",
        "field": "handle"
      },
      {
        "param": "lang",
        "field": "lang"
      }
    ],
    "source": {
      "type": "static",
      "data": [
        {
          "lang": "en",
          "handle": "data-driven-experiences",
          "title": "Data Driven Experiences",
          "overview": "The ability to process and understand user and environmental data in real time in order to provide a customized experience for the individual across multiple touch-points.",
          "body": "## Overview\n\nDADI is unique in its approach to data: the entire platform is built to facilitate Data Driven Experiences.\n\nA data driven experience is any interaction with a product (website, app or any other digital channel) that is unique to an individual as a result of decisions made on the back of person-level data.\n\nDADI puts the concept of the individual at the heart of the platform, creating real-time, person-level taxonomies of interests, and providing multiple actionable data points to enable the construction of individual-specific experiences.\n\n## Examples of data driven experiences\n\nA data driven experience can range from the simple to the highly complex, and can be constructed in both the anonymous and known user spaces.\n\nOne basic example is the delivery of movie reviews that respect regional embargos based on the user's location at the point of page request. Another basic example is the selection of new movie reviews that pays respect to reviews that user has already read, ensuring that they receive new content on each visit.\n\nA more complex example would be the selection of articles for the individual based on a person-level taxonomy of interest and weighted through the use of machine learning and proximity to other users.\n\nAnother complex example is the recommendation of a new car for a user at the point that they first interact with a car reviews website, selected through the use of a proximity mapping and enhanced with machine learning as the user engages with the process. This data could then be fed through to an on-hand call centre to enable an informed and relevant concierge service to lead the user to point of delivery of their new car.\n\n## How does this work?\n\nAt the heart of the DADI platform is the concept of the anonymous UUID: a persistent anonymized user record that is available cross product. This is provided by DADI Identity.\n\nUsed in conjunction with DADI Track, Identity enables the monitoring of every action taken within a product, and can hand this data over to the known space at the point of user sign up/in.\n\nBy applying DADI Match to content, it is possible to automatically categorize content against our common taxonomical-framework (the most comprehensive framework available). Match is a machine learning layer that is capable of understanding the meaning of actions. When matched to content and tied to a UUID, this enables person-level taxonomies to be created and evolved in real time.\n\nAll of this data is then piped into the front end generator for a product ahead of data source execution, allowing the manipulation of content based on what is known about an individual.\n\nAs the platform learns, it gains in accuracy, providing an ever greater understanding of the individual.\n\nWhen used in conjunction with a Moment Map - our communications and engagement strategy - DADI enables the creation of meaningful relationships, acting to build loyalty, increase engagement and elevate conversion."
        },
        {
          "lang": "en",
          "handle": "api-first-and-cope",
          "title": "API First & COPE",
          "overview": "API-first development is the idea that whenever you are developing a piece of shared functionality for your organization it should be exposed as a RESTful HTTP(S) API to all of your other developers.",
          "body": "## Overview\n\nTraditional product design is channel and device centric. But users inhabit a multi-channel, multi-device world.\n\nChannel and/or device centric product design results in duplicated effort and wasted engineering work. API-first development is focused on removing this technical debt through the separation of the data backend and the data consuming front end.\n\nAPI-first development is the idea that whenever you are developing a piece of shared functionality for your organization it should be exposed as a RESTful HTTP(S) API to all of your other developers. Rather than creating a library or module that needs to be added to all code bases requiring the functionality, developers can consume all the necessary functionality through the API. Having developers consume all functionality through an API enforces separation of concerns and hides internal complexity.\n\nCOPE stands for Create Once, Publish Everywhere. It is about reducing editorial overhead by freeing content for use in multiple different contexts. Simply put, COPE separates data from design, making your content reusable and future-proof for new devices or platforms.\n\nTaking an API-first development approach enables COPE and brings several additional benefits:\n\n1. [Separation of concerns](#1-separation-of-concerns)\n2. [Scalability](#2-scalability)\n3. [Reduction of language barriers](#3-reduction-of-language-barriers)\n4. [Developer liberation and specialization](#4-developer-liberation-and-specialization)\n5. [Openness and future consumer availability](#5-openness-and-future-consumer-availability)\n6. [Modularity](#6-modularity)\n\n## 1. Separation of concerns\n\nAPI-first development is the formal separation of the front end from the back end.\n\nSimilar to the Model View Controller paradigm, by decoupling data from logic from presentation, it forces a better code architecture, which in the long term decreases your technical debt. API-first development makes it easy to push data to multiple views, regardless of size or functionality.\n\n## 2. Scalability\n\nCompletely separating your front end and back end codebases helps to simplify future scalability by enabling you to scale platform components independently of each other. It allows for the client and server to sit behind their own load balancers and in their own infrastructure, giving you the ability to scale on a micro-level which brings flexibility (for example your data could be stored centrally while your client is hosted in multiple geographical locations) and cost savings.\n\n## 3. Reduction of language barriers\n\nYour API should be a reflection of your business logic. Separating it out gives you the capability of expanding into different channels and in support of different devices while utilising the same backend.\n\nYour API acts as a universal language, which any of your clients can interact with. Even as you expand, every team will be speaking and understanding the same language. The expectations are always the same: same successes, same errors. Better yet, everybody knows JSON and almost everyone is up to speed with REST, so the API is globally understood.\n\n## 4. Developer liberation and specialization\n\nAPI-first development liberates developers. The only thing application developers need to know is the request/response sequences of each API endpoint and any potential error codes. The same goes for mobile developers, and any other type of developer for that matter.\n\nIndustries move forward when knowledge can be ‘black boxed’. Imagine if, to build a web application, you had to know how to build a microchip from scratch. Thanks to specialization and division of labor all you need to focus on is the code. This is the advantage of API-first development.\n\nThe approach frees up the front end development team to focus on a few specific ways to interact with the data, and the back end team can focus on providing it in a RESTful manner.\n\n## 5. Openness and future consumer availability\n\nAPI-first makes opening your API for public consumption simple. And as a client of our own API, as you add more functionality you will be in a position to offer it to consumers without any additional overhead.\n\n## 6. Modularity\n\nWhy limit yourself to just one source of data? With modern web practices you can easily combine multiple APIs to make a powerful product quickly. And if your needs change, so can the your platform, by simply adding or removing an API."
        },
        {
          "lang": "en",
          "handle": "microservices",
          "title": "Microservices",
          "overview": "Microservices describes a method of architecting complex applications as a series of small, independent processes that communicate with each other using language-agnostic APIs.",
          "body": "## Overview\n\nThe term \"Microservice Architecture\" describes a particular way of designing software applications as suites of independently deployable services. While there is no precise definition of this architectural style, there are certain common characteristics, including organization around business capability, automated deployment, intelligence in the endpoints, and decentralized control of languages and data.\n\nWe see microservices as being a logical partner of the API-first development approach, in which complex applications are composed of small, independent processes that communicate with each other using language-agnostic APIs. These services are small, highly decoupled and focus on performing a small task.\n\n## Properties of the Microservices architecture:\n\n* The services are easy to replace\n* Services are organized around capabilities, e.g. user interface frontend, recommendation, logistics, billing, etc.\n\n## A microservices-based architecture:\n\n* Lends itself to a continuous delivery software development process\n* Is distinct from a Service-oriented architecture (SOA) in that the latter aims at integrating various (business) applications whereas several microservices belong to one application only\n\n## Products not projects\n\nMost application development efforts that we see use a project model where the aim is to deliver some piece of software which is then considered to be completed. On completion the software is handed over to a maintenance organization and the project team that built it is disbanded.\n\nMicroservice proponents tend to avoid this model, preferring instead the notion that a team should own a product over its full lifetime. A common inspiration for this is Amazon's notion of \"you build, you run it\" where a development team takes full responsibility for the software in production. This brings developers into day-to-day contact with how their software behaves in production, and increases contact with their users, as they have to take on at least some of the support burden.\n\nThe product mentality ties in with the linkage to business capabilities. Rather than looking at the software as a set of functionality to be completed, there is an ongoing relationship where the question is how can software assist its users to enhance the business capability.\n\n## How big is a microservice?\n\nAlthough \"microservice\" describes an architectural style, it's name does lead to an unfortunate focus on the literal size of a service, and arguments about what constitutes \"micro\".\n\nThe largest sizes we see follow Amazon's notion of the Two Pizza Team (i.e. the whole team can be fed by two pizzas), meaning no more than a dozen people. On the other end of the spectrum, a single developer could easily be responsible for multiple services."
        },  
        {
          "lang": "en",
          "handle": "machine-learning",
          "title": "Machine Learning",
          "overview": "Machine Learning is not really a machine. Rather it's a mathematical model capable of learning patterns in large data sets and then predicting similar patterns in new data.",
          "body": "## Overview\n\nDADI is unique in its approach to data: the entire platform is built to facilitate [Data Driven Experiences](/platform/concepts/data-driven-experiences/).\n\nAt the heart of this is a series of cognitive apps that provide predictive analysis to enable the creation of unique experiences targeted at the individual.\n\n## Cognitive insight with DADI Predict\n\nDADI Predict is the first of our machine learning apps. It is an API that simplifies audience-based predictions by using specific machine learning techniques.\n\nVery basically, events go into DADI Predict and predictions about future events come out.\n\n## A working example\n\nDADI Predict uses the concepts of events - familiar to anyone that has used GA - to allow for the simple collection of data points to model against.\n\nAn event is a grouping of four types:\n\n- Person\n- Action\n- Object\n- Weighting\n\nFor example: user A (the person) may add a Porsche 911 (the object) to their wishlist (the action).\n\nPredict uses our identity tools - specifically the guarantee of an individual and an issued UUID - to populate the identifier for the person in the event.\n\nThe actions and the objects are based on the predictions that we want to make within a product.\n\nGoing back to the example:\n\n1. User A adds a Porsche 911 to their wishlist\n2. User B adds a Porsche 911 and a Mercedes S-Class to their wishlist\n\nThis enables us to predict that User A is more likely to be interested in a Mercedes S-Class than in a randomly selected model.\n\nThe analytical approach being used is called collaborative filtering: the prediction of interests for a single user (filtering), calculated based on the interests of many users (collaborating).\n\nThe system works best at scale. Generally speaking, it needs at least 20x more data points than variables.\n\nAnd the more data you throw at it, [the better it gets](/latest/striving-to-be-less-wrong/)."
        },
        {
          "lang": "de",
          "handle": "data-driven-experiences",
          "title": "Datengestützte Erlebnisse",
          "overview": "Die Fähigkeit, Benutzer- und Umgebungsdaten in Echtzeit zu verarbeiten und zu verstehen, um eine persönliche Erfahrung des Individuums über verschiedene Berührungspunkte hinweg zu ermöglichen.",
          "body": "## Überblick\n\nDADI ist einzigartig im Umgang mit Daten: Die gesamte Plattform ist darauf ausgerichtet, datengestützte Erlebnisse zu ermöglichen.\n\nEin datengestütztes Erlebnis ist jede Interaktion mit einem Produkt (Webseite, App oder jeder andere digitale Kanal), die einzigartig für jedes Individuum ist und ein Ergebnis der früheren Entscheidungen auf Grundlage der persönlichen Daten ist.\n\nDADI macht das Konzept des Individuellen zum Herzstück seiner Plattform, erstellt in Echtzeit persönliche Taxonomien zu den Interessen und bietet so zahlreiche umsetzbare Datenpunkte, die es ermöglichen, individual-spezifische Erlebnisse zu konstruieren.\n\n## Beispiele für datengestützte Erlebnisse\n\nEin datengestütztes Erlebnis kann sich vom Einfachen bis hin zum Hochkomplexen erstrecken, und es kann sowohl im anonymen als auch im bekannten Userbereich konstruiert werden.\n\nEin grundlegendes Beispiel ist die Verfügbarkeit von Filmvorschauen, die regionale Verbote berücksichtigen, basierend auf dem Standort des Benutzers, von welchem aus er die Seite aufruft. Ein anderes grundlegendes Beispiel ist die Auswahl von Filmvorschauen, die berücksichtigt, was der Benutzer bereits gelesen hat, und somit sicherstellt, dass der Benutzer bei jedem Besuch neuen Inhalt vorfindet.\n\nEin eher komplexes Beispiel ist die Auswahl von Artikeln basierend auf einer persönlichen Taxonomy der Interessen und dessen Bewertung durch maschinelles Lernen und in der Nähe zu anderen Benutzern.\n\nEin weiteres komplexes Beispiel ist die Empfehlung eines neuen Autos für einen Benutzer zu der Zeit, zu der er sich gerade zum ersten Mal auf einer Webseite für Autobewertungen befindet, ausgewählt durch die Benutzung von Nachbarschaftsanalyse und erweitert durch maschinelles Lernen, während der Benutzer sich im Prozess befindet. Diese Daten können dann an ein vorliegendes Call Centre weitergegeben werden, um einen informierten und relevanten Concierge Service anzubieten, der den Benutzer bis zur Zustellung des neuen Autos begleitet.\n\n ## Wie funktioniert das?\n\nIm Herzen der DADI Plattform liegt das Konzept der anonymen UUID: Eine dauerhafte anonymisierte Benutzerdatei, die über verschiedene Produkte hinweg verfügbar ist. Dies wird durch DADI Identity ermöglicht. Wird es in Verbindung mit DADI Track benutzt, ermöglicht Identity die Überwachung jeglicher Aktionen, die im Produkt getätigt werden, und diese Daten können an den bekannten Ort übermittelt werden, wenn der Benutzer sich registriert/anmeldet.\n\nDie Anwendung von DADI Match auf den Inhalt ermöglicht es, Inhalt nach unserem bekannten taxonomischen Framework zu kategorisieren (das flächendeckendste Framework zur Zeit verfügbar). Match ist eine Oberfläche zu maschinellem Lernen, das in der Lage ist, die Bedeutung von Aktionen zu erkennen. Wenn es mit Inhalt kombiniert wird und an ein UUID gekoppelt wird, erlaubt es einem, persönliche Taxonomien in Echtzeit zu erstellen und herauszubilden.\n\nAll diese Daten werden dann in einen Front-End Generator für ein Produkt vor der Durchführung der Datenquelle eingespeist, was die Bearbeitung des Inhalts basierend auf allem, was über das Individuum bekannt ist, ermöglicht.\n\nWährend die Plattform lernt, wird sie akurater und bietet ein immer besseres Verständnis des Individuums.\n\nWenn es in Verbidnung mit einer Moment Map - unserer Kommunikations- und Verabredungsstrategie - kombiniert wird, ermöglicht DADI den Aufbau einer bedeutsamen Beziehung, den Aufbau von Loyalität, Erweiterung der Kundenbindung und eine verbesserte Umsetzung."
        },
        {
          "lang": "de",
          "handle": "api-first-and-cope",
          "title": "API-first und COPE",
          "overview": "Das API-first Projekt ist der Gedanke, wann auch immer ein Beitrag entwickelt wird, der geteilte Funktionalität in der Firma hat, sollte es als RESTful HTTP(S) API allen anderen Entwicklern der Firma zur Verfügung stehen.",
          "body": "## Überblick\n\nTraditionelles Produktdesign ist Kanal- und Endgerätezentriert. Aber Benutzer leben in einer Welt mit verschiedenen Kanälen und verschiedenen Endgeräten.\n\nKanal- und/oder Endgerätezentriertes Produktdesign führt zu doppeltem Arbeitsaufwand und verschwendet Arbeitskraft der Entwickler. API-first ist darauf bedacht, diese technische Bürde zu beseitigen, indem die Backend Daten und das datenintensive Frontend separiert werden\n\nAPI-first ist der Gedanke, wann auch immer ein Beitrag entwickelt wird, der geteilte Funktionalität in der Firma hat, sollte es als RESTful HTTP(S) API allen anderen Entwicklern der Firma zur Verfügung stehen.  Anstatt eine Biblothek oder Modul zu erstellen, das zu jeder Codebasis hinzugefügt werden muss, was die Voraussetzung für die Funktionalität ist, können die Entwickler auf alle nötigen Funktionen durch das API zugreifen. Wenn die Entwickler auf alle Funktionen durch das API zugreifen müssen, zwingt das zu einer Trennung der Zuständigkeiten und verschleiert interne Komplexität\n\nCOPE steht für Create Once, Publish Everywhere. Es geht darum, editoriellen Mehraufwand zu verringern, in dem der Inhalt für die Benutzung in mehreren verschiedenen Kontexten freigestellt wird. Einfach ausgedrückt trennt COPE Daten vom Design, was den Inhalt wiederverwendbar und zukunftssicher für neue Endgeräte und Plattformen macht.\n\nNutzt man die API-first Entwicklung, bringt dies COPE einige weitere Vorteile:\n\n1.Trennung der Zuständigkeiten\n2. Skalierbarkeit\n3. Verringerung von Sprachbarrieren\n4. Freiheit für Entwickler und deren Spezialisierung\n5. Offenheit und zukünftige Kundenverfügbarkeit\n6. Modularität\n\n## 1. Trennung der Zuständigkeiten\n\nAPI-first ist die formale Trennung des Frontend vom Backend.\n\nÄhnlich dem Model View Controller Paradigma, wo Daten, Logik und Präsentation entkoppelt werden, zwingt es zu einer besseren Codearchitektur, was auf lange Sicht betrachtet die technischen Hürden verringert. API-first vereinfacht es, Daten zur mehrfachen Betrachtung zu versenden, egal welcher Größe oder Funktionalität.\n\n## 2. Skalierbarkeit\n\nFrontend und Backend Codebasis komplett voneinander zu trennen hilft dabei, zukünftige Skalierbarkeit zu vereinfachen, indem es ermöglicht, Plattformkomponenten unabhängig voneinander zu skalieren. Es erlaubt sowohl dem Client als auch dem Server, hinter ihrem eigenen Load Balancer und in ihrer eigenen Infrastruktur zu sitzen, während sie die Möglichkeit haben, auf der Mikroebene zu skalieren, was Flexibilität ermöglicht (zum Beispiel können Daten zentral gespeichert werden, während der Client in verschiedenen geographischen Standorten gehosted wird) und Kosten einspart.\n\n## 3. Verringerung der Sprachbarrieren\n\nIhr API sollte ihre Geschäftsidee widerspiegeln. Ausgliedern gibt Ihnen die Möglichkeit, auf verschiedene Kanäle zu expandieren und verschiedene Endgeräte zu unterstützen, alles in Benutzung des gleichen Backends.\n\nIhr API agiert als universale Sprache, mit der all ihre Clients interagieren können. Selbst wenn sie expandieren, wird jedes Team dieselbe Sprache sprechen und verstehen. Die Erwartungen sind immer die selben: Der gleiche Erfolg, die gleichen Fehler. Besser noch, wenn jeder JSON kennt und fast jeder auf der Höhe mit REST ist, sodass API weltweit verstanden wird.\n\n## 4. Freiheit für Entwickler und deren Spezialisierung\n\nAPI-first befreit die Entwickler. Die einzige Sache, die Anwendungsentwickler wissen müssen, ist die Frage/Antwort Sequenz jedes API Endpunkts und einige potentielle Fehlercodes. Dasselbe gilt für Handyentwickler, und jede andere Art von Entwickler in diesem Bereich.\n\nDie Wirtschaft entwickelt sich weiter, wenn Wissen eine Black Box wird. Stellen sie sich vor, sie müssten wissen wie ein Mikrochip von Grundauf aufgebaut wird, um eine Internetanwendung zu erstellen. Dank der Spezialisierung und Arbeitsteilung brauchen sie sich nur auf den Code konzentrieren. Das ist der Vorteil von API-first.\n\nDieser Ansatz befreit auch das Frontend Entwicklungsteam, damit es sich auf einige spezielle Verfahren zur Interaktion mit den Daten konzentrieren kann, und das Backend Team kann sich darauf fokussieren, diese in einer RESTful Art und Weise bereitzustellen.\n\n## 5. Offenheit und zukünftige Kundenverfügbarkeit\n\nAPI-first macht die Öffnung ihres API für die Öffentlichkeit einfach. Und als Client ihres eigenen API haben sie die Möglichkeit, sobald sie mehr Funktionalität hinzufügen, ihren Kunden diese ohne zusätzlichen Mehraufwand zur Verfügung zu stellen.\n\n## 6. Modularität\n\nWarum sollten sie sich mit nur einer Datenquelle zufrieden geben? Mit modernen Internetpraktiken können Sie mehrere APIs kombinieren um schnell ein leistungsstarkes Produkt zu entwickeln. Und wenn sich ihre Wünsche ändern, kann sich auch die Plattform ändern, durch einfaches hinzufügen oder löschen eines API."
        },
        {
          "lang": "de",
          "handle": "microservices",
          "title": "Microservices",
          "overview": "Microservices beschreibt eine Methode, komplexe Anwendungen als eine Serie von kleinen, unabhängigen Prozessen aufzubauen, die unter Benutzung sprachunabhängier APIs miteinander kommunizieren.",
          "body": "## Überblick\n\nDer Begriff \"Microservice Architecture\" beschreibt ein bestimmtes Verfahren zum Design von Softwareanwendungen als eine Suite von unabhängigen, einsatzfähigen Services. Obwohl es keine präzise Definition dieses Architekturstils gibt, gibt es doch einige bestimmte Eigenschaften, unter anderem die Organisation um die geschäftliche Leistungsfähigkeit herum, automatische Einsatzfähigket, Intelligenz in den Endpunkten und dezentrale Kontrolle der Sprachen und Daten.\n\nWir sehen Microservices als logischen Partner des API-first Ansatzes, wo komplexe Anwendungen aus kleinen, unabhängigen Prozessen aufgebaut sind, die unter Benutzung von sprachunabhängiger APIs miteinander kommunizieren. Diese Services sind klein, hochgradig entkoppelt und konzentrieren sich darauf, kleine Aufgaben auszuführen.\n\n## Eigenschaften der Microservice Architecture:\n\n* Die Services lassen sich leicht ersetzen\n* Die Services sind nach ihrem Potential organisiert, z.B. User Schnittstellen Frontend, Empfehlung, Logistik, Abrechnung, etc.\n\n## Eine Microservice basierende Architektur:\n\n* Eignet sich für einen kontinuierlichen Softwareentwicklungsprozess\n* Ist abgesetzt von einer serviceorientierten Architektur (SOA) in dem Sinne, dass Letzteres zum Ziel hat, verschiedene (geschäftliche) Anwendungen zu integrieren, während Microservices nur zu einer Anwendung gehören.\n\n## Produkte, keine Projekte\n\nDie meisten Bestreben zur Anwendungsentwicklung, die wir kennen, nutzen ein Projektmodell, mit dem Ziel, dass ein Stück Software ausgeliefert wird, welches dann als abgeschlossen angesehen wird. Nach Abschluss wird die Software an eine Wartungsfirma ausgehändigt und das Projektteam, dass diese entwickelte, wird aufgelöst.\n\nBefürworter von Microservice tendieren dazu, dieses Modell zu vermeiden, und bevorzugen stattdessen lieber die Auffassung, dass das Team das Produkt über die Lebenszeit hinweg besitzen sollte. Eine gängige Inspiration dafür ist Amazons Auffassung von \"Ihr baut es, also betreibt ihr es auch\", bei der das Entwicklerteam die volle Verantwortung für die Software in der Produktion trägt. Dies bringt die Entwickler in täglichen Kontakt damit, wie sich ihre Software in der Produktion verhält und erhöht den Kontakt mit den Benutzern, weil sie zumindest einen Teil der Support Bürde tragen müssen.\n\nDie Produktmentalität ist verbunden mit der Geschäftstauglichkeit. Anstatt die Software nur als ein Satz von Funktionalitäten anzusehen, der abgeschlossen ist, gibt es eine dauerhafte Beziehung mit der Fragestellung, wie die Software den Benutzern helfen kann, ihre Geschäftstauglichkeit zu verbessern.\n\n## Wie groß ist ein Microservice?\n\nObwohl \"Microservice\" einen Architekturstil beschreibt, lässt der Name unglücklicherweise auf die wortwörtliche Größe des Service schließen, und auf Streitigkeiten, was \"micro\" alles beinhaltet.\n\nDie größte uns bekannte Größe folgt Amazons Auffassung der zwei Pizzen (d.h. das gesamte Team kann mit zwei Pizzen ernährt werden), was bedeutet, dass es nicht mehr als ein Dutzend Menschen sind. Auf der anderen Seite des Spektrums kann auch ein einzelner Entwickler leicht für mehrere Services verantwortlich sein."
        },
        {
          "lang": "de",
          "handle": "machine-learning",
          "title": "Maschinelles Lernen",
          "overview": "Maschinelles Lernen ist nicht wirklich eine Maschine. Es ist eher ein mathematisches Model, das in der Lage ist, Verhaltensmuster zu erlernen und daraufhin ähnliche Muster in neuen Daten vorherzusagen.",
          "body": "## Überblick\n\nDADI ist einzigartig im Umgang mit Daten: Die gesamte Plattform ist darauf ausgerichtet, datengestützte Erlebnisse zu ermöglichen.\n\nIm Kern liegen eine Reihe von kognitiven Anwendungen, die vorausschauende Analysen treffen um einzigartige Erfahrungen zielgerichtet auf ein Individuum zu ermöglichen.\n\n## Kognitiver Einblick mit DADI Predict\n\nDADI Predict ist die erste unserer Anwendungen für maschinelles Lernen. Es ist ein API, das zielgruppenbasierte Vorhersagen vereinfacht, in dem es spezielle Techniken zum maschinellen Lernen verwendet.\n\nIm Prinzip werden Ereignisse in DADI Predict gespeichert und eine Vorhersage über zukünftige Ereignisse kommt dabei heraus.\n\n## Ein arbeitsfähiges Beispiel\n\nDADI Predict nutzt die Konzepte von Ereignissen - bekannt für jeden, der ein GA benutzt - um die einfach Sammlung von Datenpunkten zum Abgleich zu ermöglichen.Ein Ereignis kann in 4 Teile gruppiert werden:\n\n* Person\n* Aktion\n* Objekt\n* Bedeutung\nnZum Beispiel: Benutzer A (die Person) fügt einen Porsche 911 (das Objekt) zu seiner Wunschliste hinzu (die Aktion).\n\nPredict nutzt unsere Tools zur Identifikation - im speziellen die Gewährleistung eines Individuums und eine ausgegebene UUID - um die Kennung der Person in dem Ereignis zu befüllen.\n\nDie Aktion und das Objekt basieren auf der Vorhersage, die wir innerhalb des Produkts machen möchten.\n\nZurück zum Beispiel\n\n1. Benutzer A fügt einen Porsche 911 zu seiner Wunschliste hinzu.\n2. Benutzer B fügt einen Porsche 911 und eine Mercedes S-Klasse zu seiner Wunschliste hinzu.\n\nDies erlaubt uns, vorherzusagen, dass Benutzer A wahrscheinlich eher an einer Mercedes S-Klasse interessiert sein wird als an einem zufällig ausgewählten Model.\n\nDer analytische Ansatz, der hier genutzt wird, nennt sich kollaboratives Filtern: Die Vorhersage von Interessen eines Einzelnen (filtern), ermittelt auf Basis der Interessen Vieler (kollaborativ).\n\nDas System arbeitet am besten in größeren Dimensionen. Allgemein gesagt benötigt es mindestens 20 mal mehr Datenpunkte als Variablen.\n\nUnd je mehr Daten es bekommt, desto besser wird es."
        },
        {
          "lang": "jp",
          "handle": "data-driven-experiences",
          "title": "データ駆動型エクスペリエンス",
          "overview": "複数の接点における個人向けにカスタマイズされた体験を提供するべく、リアルタイムのユーザーおよび環境データを処理して理解する能力。",
          "body": "## 概要\n\nDADIはデータへのアプローチがユニークです。プラットフォーム全体が、データ駆動型エクスペリエンスを促進ように構築されています。\n\nデータ駆動型エクスペリエンスとは、プロダクト (Webサイト、アプリ、またはその他のデジタルチャネル) とのやりとりで、個人レベルのデータを裏付けとした決定の結果として個々人にユニークとなるものです。\n\nDADIは、個人というコンセプトをプラットフォームの中心に置いています。リアルタイムに個人レベルの興味分類を作成し、個人向けのエクスペリエンスを創出できるように、複数の実行可能なデータポイントを提供します。\n\n## データ駆動型エクスペリエンスの例\n\nデータ駆動型エクスペリエンスは、単純なものから非常に複雑なものにまで及ぶ可能性があります。匿名および既知の両方のユーザー空間に構築できます。\n1つの基本的な例は、映画レビューの配信です。ページ要求時点でのユーザーの場所に基づいて地域の制限を配慮します。もう1つの基本的な例は、新しい映画のレビューを選択することです。ユーザーが既に読んだレビューを尊重して、訪問のたびに新しいコンテンツを受け取ることを保証するようにします。\n\nより複雑な例は、個人のために記事を選択することです。個人レベルの興味分類に基づき、また機械学習や他のユーザーとの近さを利用して重み付けされます。\n\nもう1つの複雑な例は、車レビューのWebサイトにユーザーが最初に対話したときにユーザーに新しい車を推奨することです。近さのマッピングを使用して選択されます。また、ユーザーが処理に関与するについて機械学習により強化されます。このデータはコールセンターにまで及びます。知識を持って適切なコンシェルジュサービスを可能として、ユーザーを新しい車の受け渡し地点に近づくように導きます。\n\n## どのように動作しますか？\nDADIプラットフォームの中心は、匿名のUUIDというコンセプトです。これは、クロスプロダクトで利用することのできる永続的で匿名のユーザーレコードです。これはDADI Identityによって提供されます。\n\nDADI Trackと連携して使用されることで、Identityはプロダクト内で行われたすべてのアクションの監視を可能とします。また、ユーザーのサインアップやサインインの時点でこのデータを既知のスペースに渡すことができます。\n\nコンテンツにDADI Matchを適用することにより、一般的な分類フレームワーク (利用可能な最も包括的なフレームワーク) に対してコンテンツを自動的に分類することが可能です。Matchは、アクションの意味を理解できる機械学習のレイヤーです。コンテンツにマッチしてUUIDに結び付けられた場合、これにより、個人レベルでの分類をリアルタイムで作成して進化させることができます。\nこのデータはすべて、データソースの実行に先立って、プロダクトのフロントエンドジェネレータにパイプされます。個人に関する分かっていることに基づいてコンテンツを操作することができます。\n\nプラットフォームの学習が進むにつれて、正確さを増し、個人に対するより進んだ理解を提供します。\n\nモーメントマップ (コミュニケーションとエンゲージメントの戦略) と連動させることで、DADIは、有意義な関係の構築、ロイヤルティの構築、エンゲージメントの強化、コンバージョンの向上を可能とします。"
        },
        {
          "lang": "jp",
          "handle": "api-first-and-cope",
          "title": "APIファーストとCOPE",
          "overview": "APIファーストの開発とは、組織に共有の機能を開発するときはいつでも、他のすべての開発者にRESTfulなHTTP(S) APIとして公開する必要があるという考え方です。",
          "body": "## 概要\n\n伝統的なプロダクト設計はチャネルとデバイスが中心です。しかし、ユーザーはマルチチャネル、マルチデバイスの世界に生きています。\n\nチャネルやデバイス中心のプロダクト設計は、重複した労力と無駄なエンジニアリング作業につながります。APIファーストの開発は、データバックエンドとデータ利用のフロントエンドとを分離することによって、この技術的債務をなくすことに着目しています。\n\nAPIファーストの開発は、組織に共有の機能を開発するときはいつでも、他のすべての開発者にRESTfulなHTTP(S) APIとして公開する必要があるという考え方です。機能を必要とするすべてのコードベースに追加する必要のあるライブラリやモジュールを作成するのではなく、開発者はAPIを通じて必要な機能をすべて使用できます。開発者にAPIを介してすべての機能を消費させると、懸念事項の分離を強制することになり、内部の複雑さを隠すことにもなります。\n\nCOPEはCreate Once、Publish Everywhereの略です。複数の異なるコンテキストで使用するためにコンテンツを解放することにより、編集のオーバーヘッドを削減するものです。簡単に言えば、COPEはデザインからデータを分離して、新しいデバイスやプラットフォームのためにコンテンツを再利用可能で将来にも利用できるようにします。\n\nAPIファーストの開発手法を採用することで、COPEが可能になり、さらにいくつかの利点がもたらされます。\n\n懸念の分離\nスケーラビリティ\n言語障壁の低減\n開発者の解放と専門化\nオープン性と将来の利用者の可用性\nモジュール性\n\n## 1.懸念の分離\n\nAPIファーストの開発は、フロントエンドとバックエンドの正式な分離です。\n\nモデル・ビュー・コントローラーのパラダイムと同様に、データをロジックとプレゼンテーションから切り離すことで、より良いコードアーキテクチャーを強制することになります。長期的には技術的な債務を減らします。APIファーストの開発により、サイズや機能に関係なく、複数のビューにデータを簡単にプッシュすることができます。\n\n## 2.スケーラビリティ\n\nフロントエンドとバックエンドのコードベースを完全に分離することで、プラットフォームコンポーネントを互いに独立してスケールさせることができるので、将来のスケーラビリティを簡素化できます。クライアントとサーバーを独自のロードバランサの背後に置き、独自のインフラストラクチャ内に配置することが可能になります。柔軟性 (たとえば、クライアントが複数の地理的な場所にホストされている場合にもデータを集中的に保存することができます) とコストの節約をもたらすマイクロレベルでの拡張が可能になります。\n\n## 3.言語障壁の低減\n\nAPIはビジネスロジックを反映している必要があります。それを分離することで、同じバックエンドを利用しながら、さまざまなチャンネルに拡張したり、さまざまなデバイスをサポートしたりすることができます。\n\nAPIは普遍的な言語として機能し、いずれのクライアントもそれと対話することができます。規模が拡大しても、すべてのチームが同じ言語を話し、理解することになります。期待するものは常に同じでで、同じ成功、同じエラーです。良いことにはJSONは誰もが知っており、ほとんどの人がRESTを知っていますので、APIは世界的に理解されています。\n\n## 4. 開発者の解放と専門化\n\nAPIファーストの開発は開発者を解放します。アプリケーション開発者が知る必要があるのは、各APIのエンドポイントのリクエスト/レスポンスのシーケンスと可能性のあるエラーコードだけです。同じことはモバイルデベロッパーにもいえます。その他のタイプの開発者にとっても同じことです。\n\n知識が「ブラックボックス化」できるとき産業は前進します。Webアプリケーションを構築するために、マイクロチップをゼロから作る方法を知っていなければならないと想像してみてください。専門化と分業のおかげで、あなたが集中する必要があるのはコードです。これはAPIファースト開発の利点です。\n\nこのアプローチにより、データとやりとりするためのいくつかの特定の方法に集中するように、フロントエンドの開発チームを開放します。またバックエンドチームは、RESTfulな方法で提供することに集中できます。\n\n## 5. オープン性と将来の利用者の可用性\n\nAPIファーストは、あなたのAPIを公開用にすることを容易にします。私たちのAPIのクライアントとして、あなたは機能を追加しつつ、追加のオーバーヘッドなしにそれを利用者に提供することができます。\n\n## 6.モジュール性\n\nなぜ1つだけのデータソースに限定するのですか？最新のWebプラクティスでは、複数のAPIを簡単に組み合わせて強力なプロダクトを素早く作成することができます。また、必要に応じてAPIを追加または削除するだけで、プラットフォームも変更できます。"
        },
        {
          "lang": "jp",
          "handle": "microservices",
          "title": "マイクロサービス",
          "overview": "マイクロサービスとは、複雑なアプリケーションを、言語に依存しないAPIを使用して互いに通信する一連の小さく独立したプロセスとして設計する方法をいいます。",
          "body": "## 概要\n\n「マイクロサービス・アーキテクチャ」という用語は、独立して配備可能なサービスのスイートとしてソフトウェア・アプリケーションを設計する特定の方法をいいます。このアーキテクチャー・スタイルの正確な定義はありませんが、ビジネス機能、自動デプロイメント、エンドポイントのインテリジェンス、言語とデータの分散管理など共通の特性があります。\n\nマイクロサービスは、APIファーストの開発アプローチの論理的パートナーであると考えられます。言語に依存しないAPIを使用して互いに通信する小さな独立したプロセスで複雑なアプリケーションが構成されています。これらのサービスは小さく、高度に分離されており、小さなタスクを実行することに焦点を当てています。\n\n## Microservicesアーキテクチャのプロパティ：\n\n* サービスは簡単に交換できます。\n* サービスは、ユーザーインターフェースのフロントエンド、レコメンド、ロジスティクス、課金などの機能を中心に構成されています。\n\n## マイクロサービスベースのアーキテクチャ：\n\n* 継続的な配信ソフトウェア開発プロセスに適しています。\n* サービス指向アーキテクチャ (SOA) とは異なります。後者はさまざまな (ビジネス) アプリケーションを統合することを目的としており、いくつかのマイクロサービスは1つのアプリケーションにのみ属しています。\n\n## プロジェクトではなくプロダクト\n\nよく見る多くのアプリケーション開発の試みは、完了できると見なされたソフトウェアの一部を提供することを目標としたプロジェクトモデルを使用しています。完成後ソフトウェアはメンテナンス組織に渡され、それを構築したプロジェクトチームは解散されます。\n\nマイクロサービスの支持者は、このモデルを避ける傾向にあります。代わりにチームがプロダクトを全ライフタイムにわたって所有しているべきであるという考えを好みます。このための一般的なインスピレーションは、開発チームが本番ソフトウェアの全面的な責任を負うというAmazonの「あなたが構築し、実行する」という概念です。これにより、開発者は、稼働中のソフトウェアがどのように動作しているかについて日常的に接触し、サポート負担の少なくとも一部を負う必要があるため、ユーザーとの接触が増えます。\n\nプロダクトのメンタリティは、ビジネス能力との関連性に結びついています。ソフトウェアを完成させる一連の機能として見るのではなく、どのようにソフトウェアがユーザーにビジネス能力を高めるのを助けることができるのかという継続的な関連性です。\n\n## マイクロサービスはどれくらいの規模ですか？\n\n「マイクロサービス」は構造上のスタイルを表しているのですが、その名前は残念ながら文字通りサービスのサイズに焦点を当て、何が「マイクロ」を構成するかという議論につながっています。\n私たちは最大のサイズはAmazonのTwo Pizza Team (すなわち、チーム全体が2つのピザで満たされる)という見解に従っています。つまり12人を超えないことになります。その一方で、単一の開発者が複数のサービスを容易に担当できます。\n"
        },
        {
          "lang": "jp",
          "handle": "machine-learning",
          "title": "機械学習",
          "overview": "機械学習は実際には機械ではありません。むしろ数学的モデルです。大きなデータセットのパターンを学習し、それから新しいデータの類似パターンを予測できます。",
          "body": "## 概要\n\nDADIはデータへのアプローチがユニークです。プラットフォーム全体は、データ駆動型エクスペリエンスを容易にするために構築されています。\n\nその中心には、個人を対象としたユニークな体験を創出するための予測分析を提供する一連の認知アプリがあります。\n\n## DADI Predictによる認知的洞察\n\nDADI Predictは、私たちの機械学習アプリケーションの第一弾です。これは、特定の機械学習手法を使用して、オーディエンスベースの予測を簡素化するAPIです。\n\n非常に基本的には、イベントがDADI Predictに入り、将来のイベントに関する予測が出てきます。\n\n## 実際の例\n\nDADI Predictはイベントの概念を使用します。これはGAを使用したことのある人には馴染み深いものです。モデル化の対象となるデータポイントのシンプルな収集を可能にします。\n\nイベントとは、4つのタイプのグループです。\n\n* Person\n* Action\n* Object\n* Weighting\n\n例：ユーザーA (人物) がポルシェ911 (オブジェクト) をウィッシュリスト (アクション) に追加したとします。\nPredictは、特に個人と発行されたUUIDの保証を得る私たちのIDツールを使用します。そのイベントにおけるその人のためのIDを追加します。\n\nアクションとオブジェクトは、プロダクト内で作成したいと思っている予測に基づいています。\n例に戻ると：\n\n* ユーザーAはポルシェ911をウィッシュリストに追加しました。\n* ユーザーBはポルシェ911とメルセデスSクラスをウィッシュリストに追加しました\n\nしたがって、ユーザーAは、無作為に選択されたモデルよりも、メルセデスSクラスに関心を持つ可能性が高いと予測することができます。\n\nここで利用されている分析アプローチは協調フィルタリングと呼ばれます。単一ユーザーの関心の予測 (フィルタリング) を、多くのユーザーの関心に基づいて (協調作業) 計算します。\n\nシステムはスケールして動作するのが最適です。一般に、変数よりも少なくとも20倍以上のデータポイントが必要です。\n投げ入れるデータが多くなればなるほど、出るものは良くなります。"
        },
        {
          "lang": "fr",
          "handle": "data-driven-experiences",
          "title": "Expériences guidées par les données",
          "overview": "La capacité de traiter et de comprendre les données de l'utilisateur et du milieu en temps réel afin de fournir une expérience personnalisée à l'individu sur plusieurs points tactiles.",
          "body": "## Vue d'ensemble\n\nDADI est unique dans son approche des données : la plate-forme entière est conçue pour faciliter les expériences guidées par les données.\nUne expérience basée sur les données est toute interaction avec un produit (site Web, application ou toute autre chaîne numérique) qui est unique pour un individu en raison des décisions prises en fonction des données au niveau de la personne.\n\nDADI met le concept de l'individu au cœur de la plate-forme, créant des taxonomies d'intérêts en temps réel, au niveau de la personne et fournissant plusieurs points de données exploitables pour permettre la construction d'expériences individuelles.\n\n## Exemples d'expériences guidés par les données\n\nUne expérience basée sur les données peut aller du simple au très complexe et peut être construite à la fois dans des espaces utilisateurs anonymes et connus.\n\nUn exemple de base est la livraison de commentaires de films qui respectent les embargos régionaux en fonction de l'emplacement de l'utilisateur au moment de la demande de page. Un autre exemple de base est la sélection de nouveaux commentaires de films qui respectent les critiques que l'utilisateur a déjà lues, en veillant à ce qu'elles reçoivent un nouveau contenu sur chaque visite.\n\nUn exemple plus complexe serait la sélection d'articles pour l'individu en fonction d'une taxonomie d'intérêt au niveau de la personne et pondérée par l'utilisation de l'apprentissage machine et la proximité d'autres utilisateurs.\nUn autre exemple complexe est la recommandation d'une nouvelle voiture pour un utilisateur au moment qu'il interagit pour la première fois avec un site Web d'évaluation de voitures, sélectionnée par l'utilisation d'un mappage de proximité et améliorée avec l'apprentissage machine à mesure que l'utilisateur s'engage dans le processus. Ces données pourraient ensuite être transmises à un centre d'appels sur place pour permettre à un service de conciergerie informé et pertinent de diriger l'utilisateur vers le point de livraison de sa nouvelle voiture.\n\n## Comment cela marche-t-il ?\n\nAu cœur de la plate-forme DADI se trouve le concept de l'UUID anonyme : un enregistrement utilisateur persistant et anonyme qui est disponible sur le produit croisé. Ceci est fourni par DADI Identity.\n\nUtilisé conjointement avec DADI Track, Identity permet de surveiller chaque action prise dans un produit et peut remettre ces données sur l'espace connu au moment de l'inscription/de la connexion.\nEn appliquant DADI Match au contenu, il est possible de classer automatiquement le contenu sur notre cadre taxonomique commun (le cadre le plus complet disponible). Match est une couche d'apprentissage machine qui est capable de comprendre le sens des actions. Lorsqu'il est adapté au contenu et lié à un UUID, cela permet de créer et d'évoluer en temps réel des taxonomies individuelles.\n\nToutes ces données sont ensuite canalisées dans le générateur frontal pour un produit avant l'exécution de la source de données, permettant la manipulation du contenu en fonction de ce qui est connu sur un individu.\n\nÀ mesure que la plate-forme apprend, elle gagne en précision, fournissant une compréhension toujours plus grande de l'individu.\nLorsqu'il est utilisé en conjonction avec une carte Moment - notre stratégie de communication et d'engagement - DADI permet de créer des relations significatives, de fidéliser, d'accroître l'engagement et d'élever la conversion.\n"
        },
        {
          "lang": "fr",
          "handle": "api-first-and-cope",
          "title": "API-first et COPE",
          "overview": "Le développement d'API-first est l'idée que, chaque fois que vous développez une fonctionnalité partagée pour votre organisation, elle devrait être exposée en tant qu'API HTTP(S) RESTful à tous vos autres développeurs.",
          "body": "## Vue d'ensemble\n\nLa conception traditionnelle des produits est centrée sur les canaux et les appareils. Mais les utilisateurs vivent dans un monde multi-canaux et multi-appareil.\n\nLa conception de produit centrée sur le canal et/ou l'appareil entraîne des efforts répétés et des travaux d'ingénierie gaspillés. Le premier développement de l'API se concentre sur l'élimination de cette dette technique grâce à la séparation du backend de données et du front end à grande consommation de données.\n\nLe premier développement de l'API-first est l'idée que, chaque fois que vous développez une fonctionnalité partagée pour votre organisation, elle devrait être exposée comme une API HTTP (S) RESTful à tous vos autres développeurs. Plutôt que de créer une bibliothèque ou un module qui doit être ajouté à toutes les bases de code requérant la fonctionnalité, les développeurs peuvent consommer toutes les fonctionnalités nécessaires via l'API. Le fait que les développeurs consomment toutes les fonctionnalités grâce à une API impose une séparation des préoccupations et dissimule la complexité interne.\n\nCOPE signifie Créer une fois, Publier partout. Il s'agit de réduire les frais éditoriaux généraux en libérant du contenu à utiliser dans de multiples contextes différents. Autrement dit, COPE sépare les données de la conception, rendant votre contenu réutilisable et à l'épreuve du futur pour de nouveaux appareils ou plates-formes.\n\nPrendre une approche de développement d'API-first active COPE et apporte plusieurs avantages supplémentaires :\n\n## 1. Séparation des problèmes\n\nLe développement d'API-first est la séparation formelle du front end du back end.\nSimilaire au paradigme Model View Controller, en découplant les données de la logique à partir de la présentation, cela force une meilleure architecture de code, ce qui, à long terme, diminue votre dette technique. Le développement d'API-first permet de transmettre facilement des données à plusieurs vues, quelle que soit leur taille ou leur fonctionnalité.\n\n## 2. Échennolabilité\n\nLa séparation complète de vos bases de code front end et back end permet de simplifier l'évolutivité future en vous permettant d'étaler les composants de la plate-forme indépendamment les uns des autres. Il permet au client et au serveur de s'asseoir derrière leurs propres équilibreurs de charge et dans leur propre infrastructure, ce qui vous permet de faire une échelle sur un micro-niveau qui apporte flexibilité (par exemple, vos données peuvent être stockées centralement pendant que votre client est hébergé en plusieurs sites géographiques) et des économies de coûts.\n\n## 3. Réduction des barrières linguistiques\n\nVotre API devrait être le reflet de votre logique métier. La séparation vous donne la possibilité de vous lancer dans différents canaux et à l'appui de différents appareils tout en utilisant le même backend.\nVotre API fonctionne comme une langue universelle, dont l'un de vos clients peut interagir. Même pendant que vous vous développez, chaque équipe parlera et comprendra la même langue. Les attentes sont toujours les mêmes : les mêmes réussites, les mêmes erreurs. Mieux encore, tout le monde connaît JSON et presque tout le monde est au courant de REST, de sorte que l'API est globalement comprise.\n\n## 4. Libération et spécialisation des développeurs\n\nLe développement d'API-first libère les développeurs. La seule chose que les développeurs d'applications doivent savoir sont les séquences de demande/réponse de chaque point d'extrémité de l'API et de tout code d'erreur potentiel. Il en va de même pour les développeurs mobiles et tout autre type de développeur.\nLes industries avancent lorsque la connaissance peut être « en boîte noire ». Imaginez si, pour créer une application Web, vous deviez savoir comment créer une puce électronique à partir de rien. Grâce à la spécialisation et à la division du travail, vous devez vous concentrer sur le code. C'est l'avantage du développement d'API.\nL'approche libère l'équipe de développement front end pour se concentrer sur quelques façons spécifiques d'interagir avec les données, et l'équipe de back-end peut se concentrer sur les fournir d'une manière RESTful.\n\n## 5. Ouverture et disponibilité future des consommateurs\n\nAPI-first permet d'ouvrir votre API pour une consommation publique simple. Et en tant que client de notre propre API, comme vous ajoutez plus de fonctionnalités, vous serez en mesure de l'offrir aux consommateurs sans frais généraux supplémentaires.\n\n## 6. Modularité\n\nPourquoi vous limiter à une seule source de données ? Avec les pratiques Web modernes, vous pouvez facilement combiner plusieurs API pour créer rapidement un produit puissant. Et si vos besoins changent, la plate-forme peut également changer, en supprimant simplement une API. "
        },
        {
          "lang": "fr",
          "handle": "microservices",
          "title": "Microservices",
          "overview": "Microservices décrit une méthode d'architecture d'applications complexes en tant que série de petits processus indépendants qui communiquent entre eux en utilisant des API indépendants de la langue.",
          "body": "## Vue d'ensemble\n\nLe terme « Architecture de Microservices » décrit une façon particulière de concevoir des applications logicielles comme des programmes de services déployables indépendamment. Bien qu'il n'existe pas de définition précise de ce style architectural, il existe certaines caractéristiques communes, y compris l'organisation autour de la capacité des entreprises, le déploiement automatisé, l'intelligence dans les points d'extrémité et le contrôle décentralisé des langues et des données.\nNous considérons Microservices comme un partenaire logique de l'approche de développement d'API-first, dans laquelle les applications complexes sont composées de petits processus indépendants qui communiquent entre eux en utilisant des API indépendants du langage. Ces services sont petits, très découplés et se concentrent sur l'exécution d'une petite tâche.\n\n## Propriétés de l'architecture de Microservices :\n\n* Les services sont faciles à remplacer\n* Les services sont organisés autour des fonctionnalités, p.ex. frontend de l'interface utilisateur, recommandation, logistique, facturation, etc.\n\n## Une architecture basée sur les microservices :\n\n* Se prête à un processus continu de développement des logiciels de livraison\n* Est différente d'une architecture orientée aux service (SOA) dans la mesure où cette dernière vise à intégrer diverses applications (commerciales) alors que plusieurs microservices appartiennent à une seule application\n\n## Produits pas projets\n\nLa plupart des efforts de développement d'applications que nous voyons utilisent un modèle de projet où l'objectif est de fournir un certain logiciel qui est alors considéré comme complété. À la fin, le logiciel est remis à un organisme de maintenance et l'équipe de projet qui l'a construit est dissoute.\n\nLes promoteurs de Microservice ont tendance à éviter ce modèle, préférant plutôt l'idée qu'une équipe devrait posséder un produit au cours de sa pleine vie. Une inspiration commune pour cela est la notion d'Amazon de « vous créez, vous l'exécutez » où une équipe de développement assume la responsabilité totale du logiciel en production. Cela amène les développeurs à se familiariser quotidiennement avec la façon dont leur logiciel se comporte en production et augmente le contact avec leurs utilisateurs, car ils doivent prendre au moins une partie de la charge de soutien.\n\nLa mentalité du produit s'inscrit en correspondance avec les capacités de l'entreprise. Plutôt que de regarder le logiciel comme un ensemble de fonctionnalités à compléter, il existe une relation continue où la question est de savoir comment le logiciel peut aider ses utilisateurs à améliorer la capacité de l'entreprise.\n\n## Quelle est la taille d'un microservice ?\n\nBien que « microservice » décrive un style architectural, son nom entraîne une approche malheureux sur la taille littérale d'un service et des discussions sur ce qui constitue « micro ».\n\nLes plus grandes tailles que nous voyons suivent la notion de l'équipe de deux pizzas d'Amazon (c'est-à-dire que toute l'équipe peut manger avec deux pizzas), ce qui signifie pas plus d'une douzaine de personnes. De l'autre côté du spectre, un seul développeur pourrait facilement être responsable de plusieurs services."
        },  
        {
          "lang": "fr",
          "handle": "machine-learning",
          "title": "Apprentissage machine",
          "overview": "L'apprentissage machine n'est pas vraiment une machine. C'est plutôt un modèle mathématique capable d'apprendre des modèles dans de grands ensembles de données, puis de prédire des modèles similaires dans de nouvelles données.",
          "body": "## Vue d'ensemble\n\nDADI est unique dans son approche des données : la plate-forme entière est conçue pour faciliter les expériences guidées par les données.\nAu cœur de cela, il existe une série d'applications cognitives qui fournissent une analyse prédictive permettant de créer des expériences uniques ciblées sur l'individu.\n\n# Aperçu cognitif avec DADI Predict\n\nDADI Predict est la première de nos applications d'apprentissage machine. C'est une API qui simplifie les prévisions basées sur l'audience en utilisant des techniques spécifiques d'apprentissage machine.\nTrès essentiellement, les événements se déroulent dans DADI Predict et les prédictions sur les événements futurs sont disponibles.\n\n# Un exemple de travail\n\nDADI Predict utilise les concepts d'événements - familiers à tous ceux qui ont utilisé GA - pour permettre la collecte simple de points de données à modeler.\n\nUn événement est un regroupement de quatre types :\n\n* Personne\n* Action\n* Objet\n* Pondération\n* \nPar exemple : l'utilisateur A (la personne) peut ajouter une Porsche 911 (l'objet) à sa liste de souhaits (l'action).\n\nPredict utilise nos outils d'identité - en particulier la garantie d'un individu et un UUID émis - pour remplir l'identifiant de la personne dans l'événement.\n\nLes actions et les objets sont basés sur les prédictions que nous voulons faire dans un produit.\n\nRevenons à l'exemple :\n\n1. L’utilisateur A ajoute une Porsche 911 à sa liste de souhaits\n2. L’utilisateur B ajoute une Porsche 911 et une Mercedes classe S à sa liste de souhaits\n\nCela nous permet de prédire que l'utilisateur A est plus susceptible d'être intéressé par une Mercedes classe S que par un modèle sélectionné au hasard.\n\nL'approche analytique utilisée est appelée filtrage collaboratif : la prédiction des intérêts pour un seul utilisateur (filtrage), calculé en fonction des intérêts de nombreux utilisateurs (collaboration).\n\nLe système fonctionne le mieux à grande échelle. D'une manière générale, il faut au moins 20 fois plus de points de données que les variables.\n\nEt plus les données que vous lancez, mieux c'est."
        },
        {
          "lang": "es",
          "handle": "data-driven-experiences",
          "title": "Experiencias impulsadas por datos",
          "overview": "La capacidad de procesar y comprender los datos de usuario y entorno en tiempo real con el fin de proporcionar una experiencia personalizada para el individuo a través de múltiples puntos de contacto.",
          "body": "## Resumen\n\nDADI es único en su enfoque de los datos: toda la plataforma está construida para facilitar las experiencias impulsadas por datos.\nUna experiencia impulsada por datos es cualquier interacción con un producto (sitio web, aplicación o cualquier otro canal digital) que es exclusiva de un individuo como resultado de decisiones tomadas en base a datos a nivel de persona.\n\nDADI pone el concepto del individuo en el centro de la plataforma, creando taxonomías de intereses en tiempo real, a nivel de persona, y proporcionando múltiples puntos de datos procesables para permitir la creación de experiencias individuales específicas.\n\n## Ejemplos de experiencias impulsadas por datos\n\nUna experiencia basada en datos puede ir de lo simple a lo sumamente complejo, y puede construirse en espacios de usuario anónimos y conocidos.\n\nUn ejemplo básico es la entrega de revisiones de películas que respeten los embargos regionales en función de la ubicación del usuario en el punto de solicitud de página. Otro ejemplo básico es la selección de nuevas revisiones de películas que respeten los comentarios que el usuario ya ha leído, garantizando que reciban nuevo contenido en cada visita.\n\nUn ejemplo más complejo sería la selección de artículos para el individuo a partir de una taxonomía de intereses personales y ponderada a través del uso del aprendizaje automático y la proximidad a otros usuarios.\n\nOtro ejemplo complejo es la recomendación de un nuevo coche para un usuario en el primer momento en que interactúa con un sitio web de comentarios de coches, seleccionado mediante el uso de un mapeo de proximidad y mejorado con el aprendizaje máquina meintras el usuario se compromete con el proceso. Estos datos después podrían dirigirse a un centro de llamadas disponible para permitir que un servicio de conserjería informado y pertinente lleve al usuario al punto de entrega de su nuevo coche.\n\n## ¿Como funciona esto?\n\nEn el corazón de la plataforma DADI está el concepto del UUID anónimo: un registro de usuario anónimo persistente que está disponible en varios productos. Esto es proporcionado por DADI Identity.\n\nUtilizado junto con DADI Track, Identity permite el monitoreo de cada acción tomada dentro de un producto, y puede entregar estos datos al espacio conocido en el momento de registro del usuario.\n\nAl aplicar DADI Match al contenido, es posible clasificar automáticamente el contenido en función de nuestro marco taxonómico común (el marco más completo disponible). Match es una capa de aprendizaje automático que es capaz de entender el significado de las acciones. Cuando se compara con el contenido y se vincula a un UUID, esto permite que las taxonomías a nivel de persona se creen y evolucionen en tiempo real.\n\nTodos estos datos se canalizan en el generador de front end para un producto antes de la ejecución de la fuente de datos, permitiendo la manipulación del contenido basado en lo que se conoce sobre un individuo.\n\nA medida que la plataforma aprende, gana en precisión, proporcionando una comprensión cada vez mayor del individuo.\n\nCuando se utiliza junto con un mapa de momentos (nuestras comunicaciones y la estrategia de participación) DADI permite la creación de relaciones notables, que actúan para desarrollar lealtad, aumentar el compromiso y elevar la conversión."
        },
        {
          "lang": "es",
          "handle": "api-first-and-cope",
          "title": "API-first y COPE",
          "overview": "El desarrollo de API-first es la idea de que cada vez que desarrolla una parte de funcionalidad compartida para su organización, debe exponerse como una API RESTful HTTP(S) a todos sus otros desarrolladores.",
          "body": "## Resumen\n\nEl diseño de producto tradicional es centrado en el canal y el dispositivo. Pero los usuarios viven en un mundo multicanal y multidispositivo.\n\nEl diseño de producto centrado en el canal y/o el dispositivo da lugar a esfuerzos duplicados y trabajo de ingeniería desperdiciado. El desarrollo de API-first se centra en la eliminación de esta deuda técnica a través de la separación del backend de datos y el frontend que consume datos.\n\nEl desarrollo de API-first es la idea de que cada vez que se desarrolla una parte de funcionalidad compartida para su organización, debe exponerse como una API RESTful HTTP(S) a todos sus otros desarrolladores. En lugar de crear una biblioteca o módulo que deba agregarse a todas las bases de código que exijan la funcionalidad, los desarrolladores pueden consumir toda la funcionalidad necesaria a través de la API. El que los desarrolladores consuman toda la funcionalidad a través de una API impide la separación de los problemas y oculta la complejidad interna.\n\nCOPE significa Crear una vez, Publicar en todas partes. Se trata de reducir la sobrecarga editorial mediante la liberación de contenido para su uso en múltiples contextos diferentes. En pocas palabras, COPE separa los datos del diseño, haciendo que su contenido sea reutilizable y esté preparado para futuros dispositivos o plataformas.\n\nLa adopción de un enfoque de desarrollo API-first permite COPE y supone varias ventajas adicionales:\n\n## 1. Separación de los problemas\n\nEl desarrollo de la primera API es la separación formal del front end del back end.\n\nSimilar al paradigma Model View Controller, al desacoplar los datos de la lógica de la presentación, obliga a una mejor arquitectura de código, lo que a largo plazo disminuye su deuda técnica. El desarrollo de API-first facilita el envío de datos a varias vistas, independientemente del tamaño o la funcionalidad.\n\n## 2. Adaptabilidad\n\nLa separación completa de las bases de código front-end y back-end ayuda a simplificar la adaptabilidad futura, permitiéndole adaptar los componentes de la plataforma independientemente entre sí. Permite que el cliente y el servidor se sientan detrás de sus propios equilibradores de carga y en su propia infraestructura, dándole la capacidad de adaptarse en un micronivel que aporte flexibilidad (por ejemplo, sus datos podrían ser almacenados centralmente mientras su cliente está alojado en múltiples ubicaciones geográficas) y ahorre costes.\n\n## 3. Reducción de las barreras lingüísticas\n\nSu API debe ser un reflejo de su lógica de negocio. La separación le da la capacidad de expandirse en diversos canales y en apoyo de diversos dispositivos mientras que utiliza el mismo backend.\n\nSu API actúa como un lenguaje universal, con el cual cualquiera de sus clientes puede interactuar. A medida que se expande, cada equipo hablará y comprenderá el mismo idioma. Las expectativas son siempre las mismas: mismos éxitos, mismos errores. Aún mejor, todo el mundo conoce JSON y casi todo el mundo está a la vanguardia con REST, por lo que la API se comprende a nivel mundial.\n\n## 4. Liberación y especialización del desarrollador\n\nEl desarrollo de API-first libera a los desarrolladores. Lo único que los desarrolladores de aplicaciones necesitan saber son las secuencias de solicitud/respuesta de cada punto final de API y cualquier código de error potencial. Lo mismo ocurre con los desarrolladores móviles, y cualquier otro tipo de desarrollador para esa materia.\n\nLas industrias avanzan cuando el conocimiento puede ser \"\"caja negra\"\". Imagínese si, para construir una aplicación web, tenía que saber cómo construir un microchip desde cero. Gracias a la especialización y la división del trabajo, todo lo que necesita para centrarse en el código está en el código. Esta es la ventaja del desarrollo de API-first.\n\nEl enfoque libera al equipo de desarrollo de front end para centrarse en algunas formas específicas de interactuar con los datos, y el equipo de back-end puede centrarse en proporcionarlo de una manera tranquila.\n\n## 5. Apertura y disponibilidad futura del consumidor\n\nLa API hace que la apertura de su API para el consumo público sea simple. Y como cliente de nuestra propia API, a medida que añada más funcionalidad, estará en condiciones de ofrecerla a los consumidores sin gastos adicionales.\n\n## 6. Modularidad\n\n¿Por qué limitarse a una sola fuente de datos? Con prácticas web modernas, puede combinar fácilmente múltiples API para hacer un producto potente rápidamente. Y si sus necesidades cambian, también lo puede hacer su plataforma, simplemente añadiendo o eliminando una API."
        },
        {
          "lang": "es",
          "handle": "microservices",
          "title": "Microservices",
          "overview": "Microservices describe un método de diseño de aplicaciones complejas como una serie de pequeños procesos independientes que se comunican entre sí utilizando API independientes del lenguaje.",
          "body": "## Resumen\n\nEl término \"\"Arquitectura de Microservice\"\" describe una forma particular de diseñar aplicaciones de software como conjuntos de servicios desplegables de forma independiente. Aunque no existe una definición precisa de este estilo arquitectónico, existen ciertas características comunes, incluida la organización en torno a la capacidad empresarial, el despliegue automatizado, la inteligencia en los puntos finales y el control descentralizado de idiomas y datos.\n\nVemos a Microservices como un socio lógico del enfoque de desarrollo de API-first, en el que las aplicaciones complejas están compuestas de pequeños procesos independientes que se comunican entre sí utilizando API independientes del lenguaje. Estos servicios son pequeños, altamente disociados y se centran en realizar una pequeña tarea.\n\n## Propiedades de la arquitectura de Microservices:\n\n* Los servicios son fáciles de reemplazar\n* Los servicios se organizan alrededor de capacidades, p. ej., interfaz de usuario frontend, recomendación, logística, facturación, etc.\n\n## Una arquitectura basada en microservicios:\n\n* Se presta a un proceso continuo de desarrollo de software de entrega\n* Es distinto de una arquitectura orientada a servicios (SOA) en la medida en que esta última tiene como objetivo la integración de varias aplicaciones (empresariales), mientras que varios microservicios pertenecen a una única aplicación\n\n## Productos no proyectos\n\nLa mayoría de los esfuerzos de desarrollo de aplicaciones que vemos utilizan un modelo de proyecto donde el objetivo es entregar algún software que se considera que se ha completado. Al finalizar, el software se entrega a una organización de mantenimiento y el equipo de proyecto que lo creó se disuelve.\nLos proponentes de microservicios tienden a evitar este modelo, prefiriendo en cambio la idea de que un equipo debe poseer un producto durante toda su vida útil. Una inspiración común para esto es la noción de Amazon de \"\"construya, ejecute\"\" donde un equipo de desarrollo asume toda la responsabilidad del software en producción. Esto permite a los desarrolladores al contacto cotidiano con el comportamiento de su software en la producción, y aumenta el contacto con sus usuarios, ya que tienen que asumir al menos parte de la carga de asistencia.\n\nLa mentalidad del producto se vincula con las capacidades empresariales. En lugar de mirar el software como un conjunto de funcionalidades que deben ser completadas, hay una relación continua en la que la pregunta es cómo el software puede ayudar a sus usuarios a mejorar la capacidad empresarial.\n\n##¿Cómo de grande es un microservicio?\n\nAunque \"\"microservicio\"\" describe un estilo arquitectónico, su nombre lleva a un desafortunado enfoque en el tamaño literal de un servicio, y disputas sobre lo que constituye \"\"micro \"\".\nLos tamaños más grandes que vemos siguen la noción de Amazon de los equipos de dos pizzas (es decir, todo el equipo puede comer con dos pizzas), lo que significa no más de una docena de personas. En el otro extremo del espectro, un solo desarrollador podría ser fácilmente responsable de múltiples servicios."
        },  
        {
          "lang": "es",
          "handle": "machine-learning",
          "title": "Aprendizaje máquina",
          "overview": "El aprendizaje máquina no es realmente una máquina. Más bien es un modelo matemático capaz de aprender patrones en grandes conjuntos de datos y luego predecir patrones similares en nuevos datos.",
          "body": "## Resumen\n\nDADI es único en su enfoque de los datos: toda la plataforma está construida para facilitar las experiencias impulsadas por datos.\n\nEn el corazón de esto hay una serie de aplicaciones cognitivas que proporcionan análisis predictivo para permitir la creación de experiencias únicas dirigidas al individuo.\n\n## Conocimiento cognitivo con DADI Predict\n\nDADI Predict es la primera de nuestras aplicaciones de aprendizaje automático. Es una API que simplifica las predicciones basadas en el público utilizando técnicas específicas de aprendizaje automático.\n\nMuy básicamente, los eventos entran en DADI Predict y salen predicciones sobre eventos futuros.\n\n## Un ejemplo de trabajo\n\nDADI Predict utiliza los conceptos de eventos, familiar para cualquier persona que haya utilizado GA, para permitir la simple recopilación de puntos de datos respecto al modelo.\nUn evento es un agrupamiento de cuatro tipos:\n\n* Persona\n* Acción\n* Objeto\n* Ponderación\n\nPor ejemplo: el usuario A (la persona) puede agregar un Porsche 911 (el objeto) a su lista de deseos (la acción).\n\nPredict utiliza nuestras herramientas de identidad, específicamente la garantía de un individuo y un UUID emitido, para rellenar el identificador de la persona en el evento.\nLas acciones y los objetos se basan en las predicciones que queremos hacer dentro de un producto.\nVolviendo al ejemplo:\n\n* El usuario A añade un Porsche 911 a su lista de deseos\n* El usuario B añade un Porsche 911 y un Mercedes S-Class a su lista de deseos\nEsto nos permite predecir que es más probable que el Usuario A esté interesado en un Mercedes Clase S que en un modelo seleccionado al azar.\n\nEl enfoque analítico que se utiliza se denomina filtrado colaborativo: la predicción de intereses para un solo usuario (filtrado), calculada sobre la base de los intereses de muchos usuarios (que colaboran).\n\nEl sistema funciona mejor a gran escala. En términos generales, necesita al menos 20 veces más puntos de datos que variables.\nY cuanto más datos arroje, mejor será."
        },
        {
          "lang": "ru",
          "handle": "data-driven-experiences",
          "title": "Опыт на основе данных",
          "overview": "Возможность обрабатывать и понимать пользовательские данные и данные об окружающей среде в режиме реального времени для обеспечения индивидуального опыта для пользователя в нескольких точках взаимодействия.",
          "body": "## Обзор\n\nПлатформа DADI уникальна в своем подходе к данным — вся платформа разработана таким образом, чтобы содействовать обеспечению опыта на основе данных.\n\nОпыт на основе данных — это любое взаимодействие с продуктом (сайтом, приложением или любым другим цифровым каналом), которое является уникальным для пользователя в результате решений, принятых на основе данных на уровне отдельного человека. \n\nDADI ставит понятие индивидуума в центр платформы, создавая в режиме реального времени таксономии интересов на уровне человека и обеспечивая множество практических информационных точек, позволяющих формировать индивидуальный опыт.\n\n## Примеры опыта на основе данных\n\nОпыт на основе данных может быть как простым, так и очень сложным, он может быть создан как в анонимных пространствах, так и в пространствах с известными пользователями.\nОдним из базовых примеров является выдача обзоров фильмов в соответствии с региональными запретами на основе данных о местоположении пользователя на момент запроса страницы. Еще одним простым примером является выбор новых обзоров фильмов на основе уже прочитанных пользователем обзоров для обеспечения нового контента при каждом посещении.\n\nБолее сложным примером будет выбор статей для индивидуума на основе таксономии интересов на уровне личности и оценки с помощью машинного обучения и близости к другим пользователям.\nЕще одним сложным примером является рекомендация нового автомобиля пользователю в момент, когда он впервые вступает во взаимодействие с сайтом, содержащим обзоры автомобилей. Выбор осуществляется с помощью сопоставления близости и расширяется с помощью технологии машинного обучения, применяемой во время взаимодействия пользователя с процессом. Затем эти данные могут быть переданы в колл-центр, чтобы специальный проинформированный отел обслуживания клиентов склонил пользователя к решению о доставке его нового автомобиля.\n\n## Как это работает?\n\nВ центре платформы DADI лежит концепция анонимного UUID — постоянной анонимной записи данных пользователя, доступной во всех компонентах продукта. Эта функция обеспечивается технологией DADI Identity.\n\nПри использовании совместно с DADI Track Identity позволяет отслеживать все действия, предпринимаемые в рамках продукта, и передавать эти данные в известное хранилище в момент регистрации/входа в систему.\n\nПри применении DADI Match к контенту можно автоматически классифицировать контент в соответствии с нашей общей таксономической структурой (наиболее обширная структура из доступных). Match — это слой машинного обучения, способный понимать значение действий. При сопоставлении с контентом и привязке к UUID он позволяет создавать и развивать таксономии на уровне индивидуума в режиме реального времени.\n\nЗатем все эти данные поступают во front-end генератор продукта перед запуском источника данных, позволяя манипулировать контентом в зависимости от того, что известно об индивидууме.\nПо мере обучения платформы она становится все более точной, обеспечивая еще большее понимание пользователя. \n\nПри использовании в сочетании с Moment Map, нашей стратегией по коммуникациям и взаимодействию, DADI позволяет строить значимые отношения, фокусируясь на развитии лояльности, повышении активности и конверсии."
        },
        {
          "lang": "ru",
          "handle": "api-first-and-cope",
          "title": "API-first и COPE",
          "overview": "Разработка по принципу API-first — это идея о том, что при разработке элемента общей функциональности для вашей организации необходимо представлять ее другим разработчикам в виде REST HTTP(S) API.",
          "body": "# Обзор\nТрадиционный дизайн продукта ориентирован на канал или устройство.\n\nНо пользователи живут в многоканальном мире с множеством устройств.\n\nОриентированный на канал и/или устройство дизайн продукта приводит к двойным усилиям и потраченной впустую работе инженеров. Разработка по принципу API-first сосредоточена на устранении этого технического долга путем разделения back-end данных и потребляющего данные front-end.\n\nРазработка по принципу API-first — это идея о том, что при разработке элемента общей функциональности для вашей организации необходимо представлять ее другим разработчикам в виде REST HTTP(S) API. Вместо создания библиотеки или модуля, которые нужно добавлять во все кодовые базы, требующие функциональности, разработчики могут использовать всю необходимую функциональность из API. Тот факт, что разработчики используют все функциональные возможности из API, обеспечивает разделение задач и скрывает внутреннюю сложность.\n\nCOPE означает \"\"Создайте Однажды и Публикуйте Везде\"\" (с англ. Create Once Publish Everywhere). Речь идет о сокращении редакционных расходов путем высвобождения контента для использования в разных контекстах. Проще говоря, COPE разделяет данные и дизайн, делая ваш контент пригодным для повторного использования и перспективным для новых устройств и платформ.\nПрименение подхода API-first позволяет использовать принцип COPE и имеет несколько дополнительных преимуществ:\n\n## 1. Разделение задач\n\nРазработка по принципу API-first — это формальное разделение front-end и back-end.\n\nПодобно парадигме Model View Controller, разделение данных, логики и презентации улучшает архитектуру кода, что в долгосрочной перспективе снижает ваш технический долг. \n\nАрхитектура API-first дает возможность с легкостью передавать данные в разном виде, независимо от размера и функциональности.\n\n## 2. Масштабируемость\n\nПолное разделение ваших front-end и back-end кодовых баз помогает упростить будущую масштабируемость, позволяя вам рассматривать компоненты платформы независимо друг от друга. Это позволяет клиенту и серверу использовать свои средства балансировки нагрузки и свою инфраструктуру, предоставляя вам возможность рассматривать компоненты на микроуровне, что, в свою очередь, обеспечивает гибкость (например, ваши данные могут храниться централизованно, в то время как ваш клиент размещается в нескольких местах) и экономию средств.\n\n## 3. Сокращение языковых барьеров\n\nВаш API должен быть отражением вашей бизнес-логики. Разделение дает вам возможность расширения на несколько каналов и поддержки разных устройств при использовании одного back-end.\n\nВаш API выступает в роли универсального языка, с которым могут взаимодействовать все ваши клиенты. Даже по мере расширения все команды будут говорить на одном языке и понимать его. Ожидания одни и те же — один успех, одни ошибки.\n\nБолее того, все знают JSON и почти все знакомы с REST, поэтому API понимают во всем мире.\n\n## 4. Освобождение и специализация разработчиков\n\nРазработка с помощью API-first освобождает разработчиков. Единственное, что нужно знать разработчикам приложений, это последовательности запросов/ответов каждой конечной точки API и любые возможные коды ошибок. То же самое касается мобильных разработчиков и любых других разработчиков в этой сфере.\nОтрасли развиваются, и знания могут быть \"\"черным ящиком\"\". Представьте, если бы для того, чтобы создать веб-приложение, необходимо было бы с нуля создать микрочип. Благодаря специализации и разделению труда все что вам нужно — это сосредоточиться на коде. В этом заключается преимущество разработки по принципу архитектуры API-first.\n\nДанный подход освобождает команду front-end разработчиков, позволяя им сосредоточиться на нескольких конкретных способах взаимодействия с данными, и позволяет команде back-end сфокусироваться на их предоставлении в режиме REST.\n\n## 5. Открытость и будущая доступность для потребителей\n\nС API-first открыть ваш API для общественного потребления очень просто. И в качестве клиента нашего собственного API, по мере добавления функциональности, вы сможете предлагать ее потребителям без каких-либо дополнительных расходов.\n\n## 6. Модульность\n\nЗачем ограничивать себя всего одним источником данных? С использованием современных веб-практик вы можете с легкостью комбинировать несколько API для быстрого создания мощного продукта. И если вам нужно внести изменения в рамках платформы, просто добавьте или удалите нужный API."
        },
        {
          "lang": "ru",
          "handle": "microservices",
          "title": "Микросервисы",
          "overview": "Микросервисы описывают метод проектирования сложных приложений в качестве набора небольших независимых процессов, которые взаимодействуют друг с другом с помощью независимых от языков API",
          "body": "## Обзор\n\nТермин \"\"архитектура микросервисов\"\" описывает конкретный способ разработки программных приложений в виде наборов независимо развертываемых сервисов. Хотя точное определение этого архитектурного стиля отсутствует, имеются определенные общие характеристики, включая организацию вокруг бизнес-возможностей, автоматическое развертывание, аналитику в конечных точках и децентрализованное управление языками и данными.\n\nМы видим микросервисы в качестве логического партнера подхода API-first, в котором сложные приложения состоят из небольших независимых процессов, которые взаимодействуют друг с другом с помощью независимых от языков API. Эти сервисы небольшие и в значительной мере раздельные, они фокусируются на выполнении небольших задач.\n\n## Характеристики архитектуры микросервисов:\n\n* Сервисы легко заменить\n* Сервисы организованы вокруг возможностей. Например, front-end интерфейса пользователя, рекомендации, логистика, счета и т. п.\n\n## Архитектура на базе микросервисов:\n\n* Предназначена для осуществления непрерывного процесса разработки программного обеспечения\n* Отличается от сервис-ориентированной архитектуры (SOA) тем, что последняя ориентирована на интеграцию различных (бизнес) приложений, в то время как несколько микросервисов принадлежат только одному приложению\n\n## Продукты, а не проекты\n\nБольшая часть наблюдаемых нами усилий, направленных на разработку приложений, используют модель проекта, где целью является сдача определенной части программного обеспечения (ПО), после чего работа считается выполненной. После выполнения ПО передается организации, занимающейся техническим обслуживанием, а команда, разработавшая его, расформировывается.\n\nСторонники микросервисов стремятся избегать данной модели, предпочитая вместо этого идею о том, что команда должна оставаться владельцем продукта в течение всего срока его службы. Общим источником вдохновения в этом плане является идея Amazon о том, что \"\"вы создаете, вы и управляете\"\", когда команда разработчиков несет полную ответственность за ПО в производстве. Это заставляет разработчиков ежедневно контактировать с тем, как их ПО функционирует в производстве, и увеличивает контакт с пользователями, так как разработчикам приходится принимать на себя хотя бы часть нагрузки службы поддержки.\n\nМенталитет продукта связан с привязкой к бизнес-возможностям. Вместо того чтобы рассматривать ПО как набор функциональных возможностей, которые нужно воплотить в жизнь, существует постоянная связь, в которой вопрос заключается в том, как программное обеспечение может помочь своим пользователям расширить бизнес-возможности.\n\n## Насколько велики микросервисы?\n\nХотя \"\"микросервис\"\" описывает архитектурный стиль, его название не указывает на неудачную сосредоточенность на буквальном размере сервиса и на аргументы о том, что означает приставка \"\"микро\"\".\n\nСамые крупные наблюдаемые нами размеры соответствуют понятию Amazon о \"\"команде на две пиццы\"\" (т. е. всю команду можно накормить двумя пиццами), то есть не более десятка людей. С другой стороны, один разработчик может запросто быть ответственным за несколько сервисов."
        },  
        {
          "lang": "ru",
          "handle": "machine-learning",
          "title": "Машинное обучение",
          "overview": "Машинное обучение — это вовсе не машина. Скорее это математическая модель, способная изучать паттерны в больших наборах данных, а затем предсказывать похожие паттерны в новых данных.",
          "body": "## Обзор\n\nПлатформа DADI уникальна в своем подходе к данным — вся платформа разработана таким образом, чтобы содействовать обеспечению опыта на основе данных.\n\nВ центре этой системы находится набор когнитивных приложений, которые осуществляют упреждающий анализ, позволяющий формировать уникальный опыт, нацеленный на человека.\n\n## Когнитивное понимание с DADI Predict\n\nDADI Predict — это первое из наших приложений для машинного обучения. Это API, который упрощает прогнозы на основе аудитории, используя специальные методы машинного обучения.\n\nВ сущности, в DADI Predict попадают события, после чего он выдает прогнозы будущих событий.\n\n## Рабочий пример\n\nDADI Predict использует понятия событий, знакомые всем, кто пользовался GA, чтобы обеспечить сопоставление с простым набором точек данных.\n\nСобытие — это группа из четырех типов:\n\n* Человек\n* Действие\n* Объект\n* Вес\n\nНапример: пользователь А (человек) может добавить Porsche 911 (объект) в свой список пожеланий (действие).\n\nPredict использует наши инструменты идентификации, в частности, гарантию личности и присвоенный UUI, для заполнения идентификатора человека в событии.\n\nДействия и объекты основаны на прогнозах, которые мы хотим сделать в рамках продукта.\n\nВернемся к примеру:\n\n* Пользователь А добавляет Porsche 911 в свой список пожеланий\n* Пользователь В добавляет Porsche 911 и Mercedes S-Class в свой список пожеланий\n\nЭто позволяет нам предсказать, что Пользователь А вероятно будет больше заинтересован в Mercedes S-Class, чем в случайно выбранной модели.\n\nИспользуемый здесь аналитический подход называют совместной фильтрацией — прогнозирование интересов одного пользователя (фильтрация) на основе рассчитанных интересов многих пользователей (совместность).\n\nСистема лучше всего работает в масштабе. В сущности, необходимо не менее чем в 20 раз больше точек данных, чем переменных.\nЧем больше данных вы добавляете, тем лучше она становится."
        },
        {
          "lang": "pt",
          "handle": "data-driven-experiences",
          "title": "Experiências Orientadas a Dados",
          "overview": "A capacidade de processar e entender dados relativos ao utilizador e ao ambiente em tempo real, por forma a proporcionar experiências personalizadas aos indivíduos em vários pontos de contacto.",
          "body": "## Visão geral\nDADI é única na sua abordagem aos dados: toda a plataforma é construída de forma a facilitar Experiências Orientadas a Dados.\nUma experiência orientada a dados é qualquer interacção com um produto (website, aplicação ou qualquer outro canal digital) que é única em relação ao indivíduo, resultando de decisões tomadas com base em dados ao nível da pessoa.\nDADI põe o conceito do indivíduo no centro da plataforma, criando taxonomias de interesses em tempo real e ao nível da pessoa, disponibilizando pontos de dados accionáveis que permitem a construção de experiências individualizadas.\n\n## Exemplos de experiências orientadas a dados\nUma experiência orientada a dados pode variar de algo simples a altamente complexo, e pode ser construída tanto no espaço dos utilizadores anónimos como de utilizadores conhecidos.\nUm exemplo básico é mostrar críticas de filmes que respeitam embargos regionais tendo em conta a localização do utilizador na altura do pedido da página. Outro exemplo simples é a selecção de críticas de filmes baseada em críticas que o utilizador já leu, garantindo que o utilizador recebe conteúdos novos a cada visita.\nUm exemplo mais complexo seria a selecção de artigos para um indivíduo baseado em taxonomias de interesse ao nível individual, medidas através de machine learning e proximidade a outros utilizadores.\nOutro exemplo complexo é a recomendação de um carro novo a um utilizador no momento em que ele interage com um website de críticas a carros, seleccionado através de um mapeamento de proximidade e melhorado com machine learning à medida que o utilizador segue o processo. Estes dados poderiam depois ser enviados para um call center, permitindo a um serviço de agentes conduzirem os utilizadores até ao ponto de entrega do seu novo carro.\n\n## Como funciona?\n\nNo coração da plataforma DADI está o conceito de um UUID anónimo: um registo de utilizador anónimo persistente que está disponível em todo o produto. Isto é gerado pelo DADI Identity.\nQuando usado em conjunto com o DADI Track, Identity permite a monitorização de todas as acções exercidas dentro de um produto, e pode disponibilizar estes dados ao espaço de utilizadores conhecidos na altura de registo ou autenticação.\n\nAo aplicar o DADI Match aos conteúdos, torna-se possível categorizar automaticamente conteúdos com base na nossa estrutura taxonómica comum (a mais completa que existe). Match é a camada de machine learning capaz de perceber o significado de acções. Quando aplicadas a conteúdos e ligadas a um UUID, permite que taxonomias ao nível da pessoa sejam criadas e evoluídas em tempo real.\n\nTodos estes dados são depois enviados para o motor front-end dos produtos antes da execução das fontes de dados, permitindo a manipulação dos conteúdos baseada no que é conhecido do indivíduo.\n\nÀ medida que a plataforma aprende, a sua precisão melhora, oferecendo um entendimento melhorado do indivíduo.\nQuando usado em conjunto com um Mapa de Momentos – a nossa estratégia de comunicação e captação – DADI permite a criação de relações com substância, permitindo a construção de lealdade, aumentar interacções e elevar o diálogo."
        },
        {
          "lang": "pt",
          "handle": "api-first-and-cope",
          "title": "API-first e COPE",
          "overview": "O desenvolvimento API-first é a ideia em que sempre que desenvolves um pedaço de funcionalidade partilhada para a tua organização, ela deve ser exposta através de um API RESTful HTTP(S) para todos os engenheiros.",
          "body": "## Visão geral\n\nO design de produtos tradicional centra-se em canais e dispositivos. Porém, os utilizadores vivem num mundo multicanal e multidispositivo. Design de produtos centrado num canal e/ou dispositivo resulta num esforço duplicado e trabalho de engenharia desperdiçado. O desenvolvimento API-first foca-se em remover esta dívida técnica através da separação do back-end de dados e do front-end que os consome.\n\nO desenvolvimento API-first é a ideia em que sempre que desenvolves um pedaço de funcionalidade partilhada para a tua organização, ela deverá ser exposta através de uma API RESTful HTTP(S) para todos os engenheiros. Em vez de criar uma biblioteca ou módulo que tem de ser adicionado a todas as bases de código que requerem a funcionalidade, os engenheiros podem consumir todas as funcionalidades de que necessitam através do API. O facto de os engenheiros consumirem as funcionalidades de que precisam através do API promove a separação de responsabilidades e abstrai complexos pormenores de implementação internos.\n\nCOPE significa Create Once, Publish Everywhere (cria uma vez, publica em todo o lado). O conceito consiste em reduzir o tempo envolvido no processo editorial através da libertação dos conteúdos para serem utilizados em diferentes contextos. Em suma, COPE separa os dados do design, tornando os teus conteúdos reutilizáveis e preparados para o futuro, no que toca a novos dispositivos e plataformas.\n\nOptar por uma abordagem de desenvolvimento API-first abre o caminho para COPE e traz vantagens adicionais:\n\n## 1. Separação de responsabilidades\n\nO desenvolvimento API-first é a separação formal entre o front-end e o back-end.\n\nTal como o paradigma Model View Controller, separar a lógica de dados da apresentação força uma melhor arquitectura de código, o que a longo prazo reduz a dívida técnica.  O desenvolvimento API-first facilita o envio de dados para vários interfaces, independentemente do tamanho ou funcionalidade.\n\n## 2. Escabilidade\n\nSeparar completamente as bases de código front-end e back-end simplifica futuras operações de escabilidade ao permitir-te que escales componentes da plataforma independentemente. Permite que o cliente e o servidor tenham cada um o seu load balancer nas suas infra-estruturas, permitindo-te que escales a um nível micro, o que traz flexibilidade (por exemplo os teus dados podem ser armazenados centralmente enquanto que o teu cliente é espalhado por várias localizações geográficas) e redução de custos.\n\n## 3. Redução de barreiras de linguagem\n\nO teu API deve reflectir a tua lógica de negócio. Separá-la dá-te a possibilidade de expandires para diferentes canais e suportares diferentes dispositivos, tudo usando o mesmo back-end.\n\nO teu API funciona como uma linguagem universal que qualquer dos teus clientes consegue entender. Mesmo quando expandes, todas as equipas conseguirão falar e entender a mesma língua. As expectativas são sempre as mesmas: os mesmos sucessos, os mesmos erros. Melhor ainda, toda a gente percebe JSON e quase toda a gente está familiarizada com REST, portanto o teu API é entendido por todos.\n\n## 4. Libertação dos engenheiros e especialização\n\nO desenvolvimento API-first liberta os engenheiros. A única coisa que os engenheiros de aplicações precisam de saber são as sequências pedido/resposta de cada endpoint do API e potenciais códigos de erros. O mesmo se aplica aos engenheiros móveis e a qualquer outro tipo de engenheiro.\n\nAs indústrias avançam rapidamente quando o conhecimento pode ser abstraído numa caixa negra. Imagina se, para construir uma aplicação, tivesses de saber como construir um microchip do zero. Graças à espacialização e divisão de tarefas, tudo o que tens de saber é o código. Esta é a grande vantagem do desenvolvimento API-first.\n\nEsta abordagem liberta a equipa de desenvolvimento front-end, permitindo que se preocupe com uma ou outra maneira específica de interagir com os dados, enquanto que a equipa back-end se pode focar em disponibilizar os dados de uma forma RESTful.\n\n## 5. Transparência e disponibilidade para consumidores futuros\n\nAPI-first simplifica a abertura do teu API para futuro consumo público. E como cliente do teu próprio API, à medida que adicionas mais funcionalidades poderás oferecê-las aos consumidores sem esforço adicional.\n\n## 6. Modularidade\n\nPorquê limitar-te a apenas uma fonte de dados? Com práticas da web modernas, podes facilmente combinar vários APIs para rapidamente formar um produto poderoso. E se os teus dados mudarem, também a tua plataforma o pode fazer, simplesmente acrescentando ou removendo um API."
        },
        {
          "lang": "pt",
          "handle": "microservices",
          "title": "Microservices",
          "overview": "Microservices são uma forma de desenhar aplicações complexas como uma série de processos pequenos e independentes que comunicam entre eles usando APIs agnósticos de linguagem.",
          "body": "## Overview\n\nThe term \"Microservice Architecture\" describes a particular way of designing software applications as suites of independently deployable services. While there is no precise definition of this architectural style, there are certain common characteristics, including organization around business capability, automated deployment, intelligence in the endpoints, and decentralized control of languages and data.\n\nWe see microservices as being a logical partner of the API-first development approach, in which complex applications are composed of small, independent processes that communicate with each other using language-agnostic APIs. These services are small, highly decoupled and focus on performing a small task.\n\n## Properties of the Microservices architecture:\n\n* The services are easy to replace\n* Services are organized around capabilities, e.g. user interface frontend, recommendation, logistics, billing, etc.\n\n## A microservices-based architecture:\n\n* Lends itself to a continuous delivery software development process\n* Is distinct from a Service-oriented architecture (SOA) in that the latter aims at integrating various (business) applications whereas several microservices belong to one application only\n\n## Products not projects\n\nMost application development efforts that we see use a project model where the aim is to deliver some piece of software which is then considered to be completed. On completion the software is handed over to a maintenance organization and the project team that built it is disbanded.\n\nMicroservice proponents tend to avoid this model, preferring instead the notion that a team should own a product over its full lifetime. A common inspiration for this is Amazon's notion of \"you build, you run it\" where a development team takes full responsibility for the software in production. This brings developers into day-to-day contact with how their software behaves in production, and increases contact with their users, as they have to take on at least some of the support burden.\n\nThe product mentality ties in with the linkage to business capabilities. Rather than looking at the software as a set of functionality to be completed, there is an ongoing relationship where the question is how can software assist its users to enhance the business capability.\n\n## How big is a microservice?\n\nAlthough \"microservice\" describes an architectural style, it's name does lead to an unfortunate focus on the literal size of a service, and arguments about what constitutes \"micro\".\n\nThe largest sizes we see follow Amazon's notion of the Two Pizza Team (i.e. the whole team can be fed by two pizzas), meaning no more than a dozen people. On the other end of the spectrum, a single developer could easily be responsible for multiple services."
        },  
        {
          "lang": "pt",
          "handle": "machine-learning",
          "title": "Machine Learning",
          "overview": " Machine Learning não é propriamente uma máquina. É um modelo matemático capaz de aprender padrões em grandes conjuntos de dados, para depois prever padrões semelhantes em novos dados.",
          "body": "## Visão geral\n\nDADI é única na sua abordagem aos dados: toda a plataforma é construída de forma a facilitar Experiências Orientadas a Dados.\nNo centro de tudo isto está uma série de aplicações cognitivas que oferecem previsões analíticas, permitindo a criação de experiências únicas focadas no indivíduo.\n\n## Conhecimento cognitivo com DADI Predict\n\nDADI Predict é a primeira das nossas aplicações de machine learning. É um API que simplifica previsões baseadas na audiência usando técnicas de machine learning.\n\nBasicamente, DADI Predict recebe eventos e devolve previsões sobre eventos futuros.\n\n## Um exemplo prático\n\nDADI Predict usa o conceito de eventos – conhecido de quem usa GA – que permite uma simples colheita de pontos de dados para modelagem.\n\nUm evento é um agrupamento de quatro tipos:\n\n* Pessoa\n* Acção\n* Objecto\n* Peso\n\nPor exemplo: utilizador A (a pessoa) pode adicionar um Porsche 911 (o objecto) à sua lista de desejos (a acção).\nPredict usa as nossas ferramentas de identidade – especificamente a garantia de um indivíduo e um UUID gerado – para popular o identificador da pessoa no evento.\n\nAs acções e os objectos são baseados nas previsões do que queremos fazer dentro de um produto.\n\nVoltando ao exemplo:\n\n* Utilizador A acrescenta um Porsche 911 à sua lista de desejos\n* Utilizador B acrescenta um Porsche 911 e um Mercedes S-Class à sua lista de desejos\n\nIsto permite-nos prever que o há maior probabilidade de o Utilizador A estar interessado num Mercedes S-Class do que noutro modelo escolhido aleatoriamente.\n\nEsta abordagem analítica chama-se filtragem colaborativa: a previsão dos interesses de um dado utilizador (filtragem), calculada através dos interesses de vários utilizadores (colaborativa).\n\nEste sistema funciona melhor em escala. De forma geral, são necessários 20x pontos de dados do que variáveis.\n\nQuantos mais dados lhe deres, melhor ele funciona."
        },
        {
          "lang": "zh_hant",
          "handle": "data-driven-experiences",
          "title": "數據驅動體驗",
          "overview": "為傳遞跨多觸點客製化個人體驗設計的即時用戶、環境數據的了解處理能力",
          "body": "## 簡介\n\nDADI 因其資料處理的方式而獨特：整體平台是皆是為傳遞數據驅動的使用者經驗架構而成。\n\n數據驅動的體驗是因個人層次資訊背後的決策所致、對個人具獨特性的任何產品互動（網站、應用程式或任何其他數位通路）。\n\nDADI 將個人作為平台的核心概念，建立即時、個人層次的興趣分類並提供多重可行的資料點來創造個人化的特殊體驗。\n\n## 數據驅動體驗範例\n\n數據驅動體驗的涵蓋範圍從簡單到高度複雜都有，也可以同時創建在匿名與具名的使用者空間內。\n\n一個基本舉例便是可根據頁面請求時的使用者所在地點來傳送符合地區禁運規定的相關電影評論。另一個例子則是能知道使用者已讀的內容來確保每次造訪都能接收新訊息的最新影評系列。\n\n而一個更複雜的例子是可根據個人層次的興趣分類以及透過機器學習方法和與其他用戶之間的相似度來權衡呈現一系列的精選文章。\n\n另一個複雜的例子則是在使用者初次與一個汽車評論網站互動時提供關於新車的建議資訊，透過使用近似度對應和隨著使用者的互動過程來強化機器學習演算；獲得的資訊可接著提供給現有的電話客服中心來傳遞資訊充分且相關的私人專屬服務，引導使用者直到收到他們的新車。\n\n## 如何運作？\n\nDADI 平台的核心概念是匿名 UUID：一種可跨產品、持久且匿名的使用者紀錄。這是由 DADI Identity 來提供服務。\n\n與 DADI Track 同時進行的 Identity 服務能監控產品內進行的所有動作，也可以在使用者登入或登出時將此資訊轉移到已具名的空間裡。\n\n藉由將 DADI Match 應用至內容，可透過比對我們所提供的通用分類標準架構（這是目前最廣泛的可用架構）來自動分類內容。Match 服務是一種可理解行動意義的機器學習層級；在符合內容且綁定至特定 UUID 時，可允許即時創造及發展個人層次的分類。\n\n接著所有這些資訊將會在資料來源執行之前輸送到為產品開發所設置的前端產生器，讓系統能根據對個人使用者所知資訊來操作內容。\n\n隨著平台不斷學習，即可增加準確度來提供具更高理解能力的個人服務。\n\n當同時與 Moment Map 一起使用時——我們的傳播與互動策略——DADI 能提供創造有意義的客戶關係並採取行動來進一步建立忠誠度、增加互動和提升轉換率。"
        },
        {
          "lang": "zh_hant",
          "handle": "api-first-and-cope",
          "title": "API 優先與 COPE 原則",
          "overview": "API 優先開發模式的概念是無論你何時為你的組織開發一部分的共享功能，都應為所有其他開發人員開放為 RESTful HTTP(S) API。",
          "body": "## 簡介\n\n傳統產品設計是以通路和裝置為中心構想的，但使用者所身處的卻是一個多通路與多裝置的世界。\n\n以通路和／或裝置為中心的產品設計會造成工作重複及不必要的工程作業，而 API 優先的開發模式正是著重透過分離已備份與使用於前端的資訊來解決這樣的技術負債問題。\n\nAPI 優先開發模式的概念在於無論你何時為你的組織開發一部分的共享功能，都應為所有其他開發人員開放為 RESTful HTTP(S) API。與其創建函式庫或模組——還得新增所有需要該功能的編碼庫，開發人員可輕鬆透過 API 來享用所有必需的功能。讓開發人員能經由 API 來利用所有功能可強化關注點分離且隱藏內部複雜性。\n\nCOPE 代表的是一次創建，多次出版。這是關於藉由開放內容在多種不同配置情境裡使用來減輕編輯工作的額外負荷。簡單來說，COPE 將資料從設計中分離，可讓你的內容可為新裝置或平台使用也能提供具未來面向的設計。\n採用 API 優先開發模式可啟動 COPE 並帶來多種額外優勢：\n\n## 1. 關注點分離\nAPI 優先開發模式是將前端從後端分離的正式契機。\n與模型—視圖—控制器 (Model-view-controller) 架構模式相似的是可藉由從邏輯和展示將資料去耦合來驅動更穩固的編碼架構，長期來看能減輕更多你的技術負債。因此無論大小或功能，API 優先開發可讓跨多種瀏覽的資訊推送更加輕鬆。\n\n## 2. 延展性\n完整分隔你的前端和後端程式碼庫可幫你藉由獨立各自拓展平台元件來簡化未來延展性。這能讓用戶端及伺服器架設在各自的負載平衡器後方及架構之內，賦予你微視層面的開發能力（譬如你的資料可被集中儲存而你的用戶端主機可同時從多個不同地理位置存取）來更加彈性靈活及節省花費。\n\n## 3. 減少語言隔閡\n你的 API 應該用來反映你的商業邏輯。將其分離能給你拓展至不同通路的能力並可在使用相同後端時支援不同裝置。\n你的 API 可作為一種讓你所有客戶都可用來進行互動的通用語言。即使你努力推懬來讓每個團隊都能使用理解相同語言，預期結果都是一樣的：相同的成功，相同的錯誤。幸好的是，無人不知 JSON 且幾乎所有人都選擇使用 REST 架構風格來加速服務，因此你的 API 可以全球通用。\n\n## 4. 開發人員解放及專業領域分工\nAPI 優先的產品開發模式可賦予開發人員更大的自由。而應用程式開發者唯一需要知道的就是每個 API 端點的請求／回應序列和任何潛在的錯誤程式碼。這對行動開發者及任何類型的相關開發人員都一樣。\n當知識可用「黑盒子」來記錄保存時，產業便可持續向前發展。想像如果你必須得從頭開始學習如何製作晶片來架構一個網路應用程式。幸好目前所有行業都是專業領域分工，所以你只要專注在程式碼上就行了。這就是 API 優先開發模式的優勢。\n這種方法不但可鬆綁前端開發團隊來使他們專心在資料互動的少量特定方法，也可讓後端團隊專注以 RESTful 風格提供服務。\n\n## 5. 開放性及未來顧客可用性\nAPI 優先能讓開啟你的 API 公共消費變得簡單。而身為我們 API 的使用客戶，當你增加越多功能，你將能免除其他額外花費便能有能力轉而為你的客群提供更多服務。\n\n## 6. 模組化\n為何把自己限制在單一資訊來源呢？如今的網路應用發展已能讓你輕鬆結合多個 API 來快速創立強大的產品。如果你的需求會隨時間改變，你的平台也是如此，因此你只需進行增加或移除 API。"
        },
        {
          "lang": "zh_hant",
          "handle": "microservices",
          "title": "微服務",
          "overview": "微服務描述的是一種將複雜應用程式如一系列使用與語言無關 (language-agnostic) 的 API 互相溝通、如同小型獨立流程般架構起來的模式",
          "body": "## 簡介\n「微服務架構」描述的是一種將軟體應用程式設計成多組獨立可部屬服務的方式。目前雖然尚無對這種架構風格的精確定義，但微服務架構包含了像是對商業能力的組織、自動部屬、端點智慧及去中心的語言及資訊控制等共同特性。\n我們將微服務視為 API 優先開發方法的理想夥伴——複雜的應用程式皆是由可以與語言無關 ( language-agnostic) 的 API 互相溝通的小型獨立流程所組成。這些服務都是小型、高度去耦合的並可專注於執行小型任務。\n\n微服務架構特性：\n\n* 每個服務皆容易替代\n* 每個服務皆以能力來組織分類：例如使用者介面、前端、推薦系統、物流、帳務等。\n\n以微服務為基礎的架構：\n\n* 適用於持續交付 (Continuous Delivery) 的軟體開發流程\n* 與服務導向架構 (Service-Oriented Architecture) 不同的是後者是整合各種（商業）應用程式，而微服務只屬於一個應用程式\n\n## 產品並非專案計畫\n\n我們所見過大部分使用專案模式來進行的應用程式開發工作，目標都只是交付一部份的軟體內容就認為已經完成了。軟體在完成後就轉由某個維護組織負責，而整個專案團隊就解散了。\n\n微服務提倡者則傾向避免這種模式，偏好開發團隊應該對產品完整的生命週期全程負責。這個想法的一個啟發來源是亞馬遜所提出「一創造，就持續完善」(you build, you run it) 的持續交付開發流程，意味開發團隊應對其所生產的軟體產品負起全責。這為開發人員帶來了關於產品在生產過程中相關表現的日常接觸並提升了與使用者的接觸機會——也由於他們本身也得負責一些相關技術支援。\n\n產品感質與商業能力之間的連繫是彼此配合的。與其將軟體視為待完成的一套功能組合而已，這種可持續發展的長久關係正是能用來思索軟體如何協助使用者來提升商業能力的契機。\n\n## 微服務有多大？\n\n雖然「微服務」描述的是一種軟體架構風格，但它的名稱並不關於一個服務的實際大小或者何謂「微型」的爭論。\n\n我們所見過最大的類型是亞馬遜公司所謂的「兩個披薩」原則（意即兩個披薩就應足以餵飽整個團隊），代表不超過十來多人的精小團隊。在另一方面，開發人員也可以更簡單地單獨負責多項服務。"
        },  
        {
          "lang": "zh_hant",
          "handle": "machine-learning",
          "title": "機器學習",
          "overview": "機器學習並不是真的機器，而是一種能在大型資料集裡學習規律模式且能在新資料裡預測相似規律的的數學模型",
          "body": "## 簡介\n\nDADI 因其資料處理的方式而獨特：整體平台是皆是為傳遞數據驅動的使用者經驗架構而成。\n\n我們的核心是一系列提供預測分析技術來創造個人化獨特使用精驗的智慧辨識應用程式。\n\n## DADI Predict 的認知洞察技術\n\nDADI Predict 是我們開發的第一款機器學習應用程式，是一個可使用特定機器學習技術來簡化使用者預測的應用程式介面 (API)。\n基本上，事件將會進入我們的 DADI Predict 系統並分析出有關未來事件的預測。\n\n## 工作示範\n\nDADI Predict 採用事件概念——對任何使用過 Google Analytics 都熟悉的方法——來允許對簡單集合的資料點進行模組分析。\n事件包含四種要素類型：\n\n* 對象\n* 動作\n* 物件\n* 權重\n\n例如：使用者 A（對象）可能會將一輛 Porsche 911（物件）加到他們的願望清單（動作）。\n\nPredict 便會使用我們的身分辨識工具——專門確保個人身分及已發行的 UUID——來為事件中的對象填入辨識碼。\n\n動作和物件皆是根據我們想在產品內進行的預測分析。\n回到剛才的例子：\n\n* 使用者 A 將一輛保時捷 911 增加到願望清單\n* 使用者 B 將一輛保時捷 911 和賓士 S-Class 增加到願望清單\n這讓我們能預測出使用者 A 比起隨機挑選的型號，更有可能對賓士 S-Class 感到興趣。\n\n這種採用的分析方式稱為協同過濾：可根據許多使用者（協同合作）的興趣來為個人使用者進行興趣資訊分析的預測。\n\n本系統在大規模運作下成效最佳。一般來說，至少需要比變數大 20 倍以上的資料點。\n\n因此提供越多資料，獲得的成效也越高。"
        }
      ]
    }
  }
}
